# Context Dump: Tour Breaker
# Date: 2026-02-07 16:56:06
# File Count: 9

===== BEGIN: Docs\TourBreakerService.md =====
# TourBreakerService.md

## Service Implementation: TourBreakerService

**Version:** Current implementation (updated 2026-02-07)  
**Layer:** Service Layer (Domain Logic)  
**Dependencies:** `PgnReader`, `PgnWriter`  
**Thread Safety:** Safe for concurrent calls with separate output directories.

## 1. Objective

Split a PGN database into tournament files based on event/site/year with Elo and game count thresholds.

## 2. Public API (Actual)

```csharp
public interface ITourBreakerService
{
    Task<int> BreakTournamentsAsync(
        string inputFilePath,
        string outputDirectory,
        int minElo,
        int minGames,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default);
}
```

## 3. High-Level Pipeline (Actual)

1. **Pass 1:** Scan all games and build tournament metadata.
2. **Filter tournaments** by:
   - All players meet `minElo`
   - `Games >= minGames`
   - `Games >= Players/2`
3. **Pass 2:** Write games into per‑tournament files.

## 4. Output Naming

Files are named:
```
<minDate>-<maxDate>-<event-name>.pgn
```
where dates are `YYYYMMDD` (unknown digits replaced with `0`), and event name is sanitized to lowercase hyphenated text.

## 5. Progress Reporting

Reports percent based on games processed in pass 2.

## 6. Limitations

- Tournament key uses `Event|Site|Year`.
- Writes are append‑based (no temp file per tournament).
===== END: Docs\TourBreakerService.md =====

===== BEGIN: PgnTools\Helpers\FilePickerHelper.cs =====
using System.Collections.Generic;
using System.Linq;
using Windows.Storage;
using Windows.Storage.Pickers;

namespace PgnTools.Helpers;

/// <summary>
/// Helper class for file/folder pickers in WinUI 3 Unpackaged apps.
/// Handles the IInitializeWithWindow pattern required for unpackaged apps.
/// </summary>
public static class FilePickerHelper
{
    /// <summary>
    /// Opens a file picker to select a single file.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <param name="fileTypeFilters">File type filters (e.g., ".pgn", ".txt").</param>
    /// <returns>The selected StorageFile, or null if cancelled.</returns>
    public static async Task<StorageFile?> PickSingleFileAsync(
        nint windowHandle,
        string? settingsIdentifier,
        params string[] fileTypeFilters)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileOpenPicker();

        // Initialize with window handle for unpackaged apps
        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var addedFilter = false;
        foreach (var filter in NormalizeFilters(fileTypeFilters))
        {
            picker.FileTypeFilter.Add(filter);
            addedFilter = true;
        }

        if (!addedFilter)
        {
            picker.FileTypeFilter.Add("*");
        }

        return await picker.PickSingleFileAsync();
    }

    /// <summary>
    /// Opens a file picker to select multiple files.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <param name="fileTypeFilters">File type filters (e.g., ".pgn", ".txt").</param>
    /// <returns>The selected StorageFiles, or empty if cancelled.</returns>
    public static async Task<IReadOnlyList<StorageFile>> PickMultipleFilesAsync(
        nint windowHandle,
        string? settingsIdentifier,
        params string[] fileTypeFilters)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileOpenPicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var addedFilter = false;
        foreach (var filter in NormalizeFilters(fileTypeFilters))
        {
            picker.FileTypeFilter.Add(filter);
            addedFilter = true;
        }

        if (!addedFilter)
        {
            picker.FileTypeFilter.Add("*");
        }

        return await picker.PickMultipleFilesAsync();
    }

    /// <summary>
    /// Opens a file picker to save a file.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="suggestedFileName">Suggested file name.</param>
    /// <param name="fileTypeChoices">Dictionary of file type descriptions to extensions.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <returns>The selected StorageFile, or null if cancelled.</returns>
    public static async Task<StorageFile?> PickSaveFileAsync(
        nint windowHandle,
        string suggestedFileName,
        Dictionary<string, IList<string>> fileTypeChoices,
        string? settingsIdentifier = null)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileSavePicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        picker.SuggestedFileName = suggestedFileName;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var normalizedChoices = new List<(string Label, List<string> Extensions)>();
        foreach (var choice in fileTypeChoices)
        {
            var normalizedExtensions = NormalizeFilters(choice.Value).ToList();
            if (normalizedExtensions.Count == 0)
            {
                continue;
            }

            normalizedChoices.Add((choice.Key, normalizedExtensions));
            picker.FileTypeChoices.Add(choice.Key, normalizedExtensions);
        }

        if (string.IsNullOrWhiteSpace(picker.DefaultFileExtension))
        {
            foreach (var choice in normalizedChoices)
            {
                var extension = choice.Extensions[0];
                if (!string.IsNullOrWhiteSpace(extension))
                {
                    picker.DefaultFileExtension = extension.StartsWith(".", StringComparison.Ordinal)
                        ? extension
                        : $".{extension}";
                    break;
                }
            }
        }

        return await picker.PickSaveFileAsync();
    }

    /// <summary>
    /// Opens a folder picker to select a folder.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <returns>The selected StorageFolder, or null if cancelled.</returns>
    public static async Task<StorageFolder?> PickFolderAsync(nint windowHandle, string? settingsIdentifier = null)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FolderPicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        picker.FileTypeFilter.Add("*");
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        return await picker.PickSingleFolderAsync();
    }

    private static void ValidateWindowHandle(nint windowHandle)
    {
        if (windowHandle == 0)
        {
            throw new ArgumentException("Window handle (HWND) cannot be zero.", nameof(windowHandle));
        }
    }

    private static IEnumerable<string> NormalizeFilters(IEnumerable<string> filters)
    {
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var filter in filters)
        {
            if (string.IsNullOrWhiteSpace(filter))
            {
                continue;
            }

            var trimmed = filter.Trim();
            var normalized = trimmed == "*"
                ? "*"
                : trimmed.StartsWith(".", StringComparison.Ordinal)
                    ? trimmed
                    : $".{trimmed}";

            if (seen.Add(normalized))
            {
                yield return normalized;
            }
        }
    }
}
===== END: PgnTools\Helpers\FilePickerHelper.cs =====

===== BEGIN: PgnTools\Helpers\FileReplacementHelper.cs =====
// PGNTOOLS-TABLEBASES-BEGIN
using System.IO;

namespace PgnTools.Helpers;

public static class FileReplacementHelper
{
    private const int MaxReplaceAttempts = 6;

    public static string CreateTempFilePath(string destinationPath)
    {
        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        var directory = Path.GetDirectoryName(destinationPath);
        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.GetTempPath();
        }

        var fileName = Path.GetFileName(destinationPath);
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "output";
        }

        var tempName = $".{fileName}.{Guid.NewGuid():N}.tmp";
        return Path.Combine(directory, tempName);
    }

    public static void ReplaceFile(string tempFilePath, string destinationPath)
    {
        if (string.IsNullOrWhiteSpace(tempFilePath))
        {
            throw new ArgumentException("Temp file path is required.", nameof(tempFilePath));
        }

        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        if (!File.Exists(tempFilePath))
        {
            throw new FileNotFoundException("Temp file not found.", tempFilePath);
        }

        if (Path.GetDirectoryName(destinationPath) is { Length: > 0 } directory)
        {
            Directory.CreateDirectory(directory);
        }

        Exception? lastError = null;
        for (var attempt = 1; attempt <= MaxReplaceAttempts; attempt++)
        {
            try
            {
                var backupPath = CreateBackupPath(destinationPath);
                try
                {
                    File.Replace(tempFilePath, destinationPath, backupPath, ignoreMetadataErrors: true);
                    TryDeleteBackup(backupPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    File.Move(tempFilePath, destinationPath, overwrite: true);
                    return;
                }
            }
            catch (IOException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                Thread.Sleep(attempt * 100);
            }
            catch (UnauthorizedAccessException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                Thread.Sleep(attempt * 100);
            }
        }

        throw new IOException(
            $"Failed to replace '{destinationPath}' after {MaxReplaceAttempts} attempts. The file may be locked by another process.",
            lastError);
    }

    public static async Task ReplaceFileAsync(string tempFilePath, string destinationPath, CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(tempFilePath))
        {
            throw new ArgumentException("Temp file path is required.", nameof(tempFilePath));
        }

        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        if (!File.Exists(tempFilePath))
        {
            throw new FileNotFoundException("Temp file not found.", tempFilePath);
        }

        if (Path.GetDirectoryName(destinationPath) is { Length: > 0 } directory)
        {
            Directory.CreateDirectory(directory);
        }

        Exception? lastError = null;
        for (var attempt = 1; attempt <= MaxReplaceAttempts; attempt++)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                var backupPath = CreateBackupPath(destinationPath);
                try
                {
                    File.Replace(tempFilePath, destinationPath, backupPath, ignoreMetadataErrors: true);
                    TryDeleteBackup(backupPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    File.Move(tempFilePath, destinationPath, overwrite: true);
                    return;
                }
            }
            catch (IOException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                await Task.Delay(attempt * 100, ct).ConfigureAwait(false);
            }
            catch (UnauthorizedAccessException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                await Task.Delay(attempt * 100, ct).ConfigureAwait(false);
            }
        }

        throw new IOException(
            $"Failed to replace '{destinationPath}' after {MaxReplaceAttempts} attempts. The file may be locked by another process.",
            lastError);
    }

    private static string CreateBackupPath(string destinationPath)
    {
        var directory = Path.GetDirectoryName(destinationPath);
        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.GetTempPath();
        }

        var fileName = Path.GetFileName(destinationPath);
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "output";
        }

        var backupName = $".{fileName}.{Guid.NewGuid():N}.bak";
        return Path.Combine(directory, backupName);
    }

    private static void TryDeleteBackup(string backupPath)
    {
        try
        {
            if (File.Exists(backupPath))
            {
                File.Delete(backupPath);
            }
        }
        catch
        {
        }
    }
}
// PGNTOOLS-TABLEBASES-END
===== END: PgnTools\Helpers\FileReplacementHelper.cs =====

===== BEGIN: PgnTools\Helpers\FileValidationHelper.cs =====
// PGNTOOLS-TABLEBASES-BEGIN
using System.IO;
using Windows.Storage;

namespace PgnTools.Helpers;

/// <summary>
/// Helpers for validating file and folder access selected via pickers.
/// </summary>
public static class FileValidationHelper
{
    public static async Task<(bool Success, string? ErrorMessage)> ValidateReadableFileAsync(StorageFile file)
    {
        try
        {
            using var stream = await file.OpenReadAsync();
            return (true, null);
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }

    public static async Task<(bool Success, string? ErrorMessage)> ValidateWritableFolderAsync(string folderPath)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(folderPath))
            {
                return (false, "Folder path is empty.");
            }

            Directory.CreateDirectory(folderPath);

            var testFile = Path.Combine(folderPath, $".pgn_tools_write_{Guid.NewGuid():N}");
            await File.WriteAllTextAsync(testFile, "test");
            File.Delete(testFile);

            return (true, null);
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }
}
// PGNTOOLS-TABLEBASES-END
===== END: PgnTools\Helpers\FileValidationHelper.cs =====

===== BEGIN: PgnTools\Helpers\PgnHeaderExtensions.cs =====
namespace PgnTools.Helpers;

public static class PgnHeaderExtensions
{
    public static bool TryGetHeaderValue(
        this IReadOnlyDictionary<string, string> headers,
        string key,
        out string value)
    {
        if (headers == null)
        {
            throw new ArgumentNullException(nameof(headers));
        }

        if (string.IsNullOrEmpty(key))
        {
            value = string.Empty;
            return false;
        }

        if (headers.TryGetValue(key, out var found))
        {
            value = found ?? string.Empty;
            return true;
        }

        foreach (var header in headers)
        {
            if (string.Equals(header.Key, key, StringComparison.OrdinalIgnoreCase))
            {
                value = header.Value;
                return true;
            }
        }

        value = string.Empty;
        return false;
    }

    public static string? GetHeaderValueOrDefault(
        this IReadOnlyDictionary<string, string> headers,
        string key)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : null;
    }

    public static string GetHeaderValueOrDefault(
        this IReadOnlyDictionary<string, string> headers,
        string key,
        string defaultValue)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : defaultValue;
    }

    public static bool TryGetHeaderValue(
        this IReadOnlyList<KeyValuePair<string, string>> headers,
        string key,
        out string value)
    {
        if (headers == null)
        {
            throw new ArgumentNullException(nameof(headers));
        }

        if (string.IsNullOrEmpty(key))
        {
            value = string.Empty;
            return false;
        }

        for (var i = headers.Count - 1; i >= 0; i--)
        {
            var header = headers[i];
            if (string.Equals(header.Key, key, StringComparison.OrdinalIgnoreCase))
            {
                value = header.Value;
                return true;
            }
        }

        value = string.Empty;
        return false;
    }

    public static string? GetHeaderValueOrDefault(
        this IReadOnlyList<KeyValuePair<string, string>> headers,
        string key)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : null;
    }

    public static string GetHeaderValueOrDefault(
        this IReadOnlyList<KeyValuePair<string, string>> headers,
        string key,
        string defaultValue)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : defaultValue;
    }
}
===== END: PgnTools\Helpers\PgnHeaderExtensions.cs =====

===== BEGIN: PgnTools\Services\TourBreakerService.cs =====
using System.Text;
using System.Text.RegularExpressions;

namespace PgnTools.Services;

public interface ITourBreakerService
{
    Task<int> BreakTournamentsAsync(
        string inputFilePath,
        string outputDirectory,
        int minElo,
        int minGames,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// Splits a PGN database into tournament files based on event/site/year filters.
/// </summary>
public sealed class TourBreakerService : ITourBreakerService
{
    private const int BufferSize = 65536;

    private readonly PgnReader _pgnReader;
    private readonly PgnWriter _pgnWriter;

    private sealed class TourMeta
    {
        public string Name { get; set; } = string.Empty;
        public int Games { get; set; }
        public HashSet<string> Players { get; } = new(StringComparer.OrdinalIgnoreCase);
        public bool AllMeetElo { get; set; } = true;
        public string MinDate { get; set; } = "9999.99.99";
        public string MaxDate { get; set; } = "0000.00.00";
    }

    public TourBreakerService(PgnReader pgnReader, PgnWriter pgnWriter)
    {
        _pgnReader = pgnReader;
        _pgnWriter = pgnWriter;
    }

    public async Task<int> BreakTournamentsAsync(
        string inputFilePath,
        string outputDirectory,
        int minElo,
        int minGames,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(inputFilePath))
        {
            throw new ArgumentException("Input file path is required.", nameof(inputFilePath));
        }

        if (string.IsNullOrWhiteSpace(outputDirectory))
        {
            throw new ArgumentException("Output directory is required.", nameof(outputDirectory));
        }

        var inputFullPath = Path.GetFullPath(inputFilePath);
        var outputFullPath = Path.GetFullPath(outputDirectory);

        if (!File.Exists(inputFullPath))
        {
            throw new FileNotFoundException("Input PGN file not found.", inputFullPath);
        }

        Directory.CreateDirectory(outputFullPath);

        // Pass 1: scan tournaments
        var tournaments = new Dictionary<string, TourMeta>(StringComparer.OrdinalIgnoreCase);
        var totalGames = 0L;

        await foreach (var game in _pgnReader.ReadGamesAsync(inputFullPath, cancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            totalGames++;

            var key = GetKey(game);
            if (!tournaments.TryGetValue(key, out var meta))
            {
                meta = new TourMeta
                {
                    Name = game.Headers.GetHeaderValueOrDefault("Event", "?")
                };
                tournaments[key] = meta;
            }

            meta.Games++;

            if (game.Headers.TryGetHeaderValue("White", out var white) && !string.IsNullOrWhiteSpace(white))
            {
                meta.Players.Add(white);
            }

            if (game.Headers.TryGetHeaderValue("Black", out var black) && !string.IsNullOrWhiteSpace(black))
            {
                meta.Players.Add(black);
            }

            var whiteElo = TryParseElo(game.Headers, "WhiteElo");
            var blackElo = TryParseElo(game.Headers, "BlackElo");
            if (whiteElo < minElo || blackElo < minElo)
            {
                meta.AllMeetElo = false;
            }

            var date = game.Headers.GetHeaderValueOrDefault("Date", "????.??.??");
            if (string.Compare(date, meta.MinDate, StringComparison.Ordinal) < 0)
            {
                meta.MinDate = date;
            }

            if (string.Compare(date, meta.MaxDate, StringComparison.Ordinal) > 0)
            {
                meta.MaxDate = date;
            }
        }

        // Filter valid tournaments
        var validKeys = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var kv in tournaments)
        {
            var playerMin = Math.Max(1, kv.Value.Players.Count / 2);
            if (kv.Value.AllMeetElo && kv.Value.Games >= minGames && kv.Value.Games >= playerMin)
            {
                validKeys.Add(kv.Key);
            }
        }

        if (validKeys.Count == 0 || totalGames == 0)
        {
            progress?.Report(100);
            return 0;
        }

        // Pass 2: write filtered tournaments
        var processedGames = 0L;

        await foreach (var game in _pgnReader.ReadGamesAsync(inputFullPath, cancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            processedGames++;

            var key = GetKey(game);
            if (!validKeys.Contains(key))
            {
                ReportProgress(progress, processedGames, totalGames);
                continue;
            }

            var meta = tournaments[key];
            var filename = GenerateFilename(meta);
            var path = Path.Combine(outputFullPath, filename);

            var needsSeparator = File.Exists(path) && new FileInfo(path).Length > 0;

            await using var stream = new FileStream(
                path,
                FileMode.Append,
                FileAccess.Write,
                FileShare.Read,
                BufferSize,
                FileOptions.SequentialScan | FileOptions.Asynchronous);

            using var writer = new StreamWriter(stream, new UTF8Encoding(false), BufferSize, leaveOpen: true);

            if (needsSeparator)
            {
                await writer.WriteLineAsync();
            }

            await _pgnWriter.WriteGameAsync(writer, game, cancellationToken);
            await writer.FlushAsync();

            ReportProgress(progress, processedGames, totalGames);
        }

        progress?.Report(100);
        return validKeys.Count;
    }

    private static void ReportProgress(IProgress<double>? progress, long processedGames, long totalGames)
    {
        if (progress == null || totalGames <= 0)
        {
            return;
        }

        var percent = Math.Clamp((double)processedGames / totalGames * 100.0, 0, 100);
        progress.Report(percent);
    }

    private static int TryParseElo(IReadOnlyDictionary<string, string> headers, string key)
    {
        return headers.TryGetHeaderValue(key, out var value) && int.TryParse(value, out var elo)
            ? elo
            : 0;
    }

    private static string GetKey(PgnGame game)
    {
        var evt = game.Headers.GetHeaderValueOrDefault("Event", "?");
        var site = game.Headers.GetHeaderValueOrDefault("Site", "?");
        var date = game.Headers.GetHeaderValueOrDefault("Date", "????");
        var year = date.Length >= 4 ? date[..4] : "????";
        return $"{evt}|{site}|{year}";
    }

    private static string GenerateFilename(TourMeta meta)
    {
        var start = meta.MinDate.Replace(".", string.Empty, StringComparison.Ordinal).Replace("?", "0", StringComparison.Ordinal);
        var end = meta.MaxDate.Replace(".", string.Empty, StringComparison.Ordinal).Replace("?", "0", StringComparison.Ordinal);
        var safeName = Regex.Replace(meta.Name.ToLowerInvariant(), "[^a-z0-9]+", "-").Trim('-');
        if (string.IsNullOrWhiteSpace(safeName))
        {
            safeName = "tournament";
        }

        return $"{start}-{end}-{safeName}.pgn";
    }
}
===== END: PgnTools\Services\TourBreakerService.cs =====

===== BEGIN: PgnTools\ViewModels\Tools\TourBreakerViewModel.cs =====
using System.IO;

namespace PgnTools.ViewModels.Tools;

/// <summary>
/// ViewModel for the Tournament Breaker tool.
/// </summary>
public partial class TourBreakerViewModel(
    ITourBreakerService tourBreakerService,
    IWindowService windowService,
    IAppSettingsService settings) : BaseViewModel, IInitializable, IDisposable
{
    private readonly ITourBreakerService _tourBreakerService = tourBreakerService;
    private readonly IAppSettingsService _settings = settings;
    private readonly IWindowService _windowService = windowService;
    private CancellationTokenSource? _cancellationTokenSource;
    private readonly SemaphoreSlim _executionLock = new(1, 1);
    private bool _disposed;
    private const string SettingsPrefix = nameof(TourBreakerViewModel);

    [ObservableProperty]
    private string _inputFilePath = string.Empty;

    [ObservableProperty]
    private string _inputFileName = string.Empty;

    [ObservableProperty]
    private string _outputFolderPath = string.Empty;

    [ObservableProperty]
    private string _outputFolderName = string.Empty;

    [ObservableProperty]
    private int _minElo = 2700;

    [ObservableProperty]
    private int _minGames = 4;

    [ObservableProperty]
    private bool _isRunning;

    [ObservableProperty]
    private double _progressValue;

    [ObservableProperty]
    private string _statusMessage = "Select an input PGN and output folder";
    public void Initialize()
    {
        Title = "Tournament Breaker";
        StatusSeverity = InfoBarSeverity.Informational;
        LoadState();
    }
    [RelayCommand]
    private async Task SelectInputFileAsync()
    {
        try
        {
            var file = await FilePickerHelper.PickSingleFileAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.Input",
                ".pgn");
            if (file == null)
            {
                return;
    }
            var validation = await FileValidationHelper.ValidateReadableFileAsync(file);
            if (!validation.Success)
            {
                StatusMessage = $"Cannot access file: {validation.ErrorMessage}";
                StatusSeverity = InfoBarSeverity.Error;
                return;
    }
            InputFilePath = file.Path;
            InputFileName = file.Name;
            StatusMessage = $"Selected input: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting input file: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand]
    private async Task SelectOutputFolderAsync()
    {
        try
        {
            var folder = await FilePickerHelper.PickFolderAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.OutputFolder");
            if (folder == null)
            {
                return;
    }
            var validation = await FileValidationHelper.ValidateWritableFolderAsync(folder.Path);
            if (!validation.Success)
            {
                StatusMessage = $"Cannot write to folder: {validation.ErrorMessage}";
                StatusSeverity = InfoBarSeverity.Error;
                return;
    }
            OutputFolderPath = folder.Path;
            OutputFolderName = folder.Name;
            StatusMessage = $"Selected output folder: {folder.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting output folder: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand(CanExecute = nameof(CanRun))]
    private async Task RunAsync()
    {
        if (string.IsNullOrWhiteSpace(InputFilePath) || string.IsNullOrWhiteSpace(OutputFolderPath))
        {
            return;
    }
        var folderValidation = await FileValidationHelper.ValidateWritableFolderAsync(OutputFolderPath);
        if (!folderValidation.Success)
        {
            StatusMessage = $"Cannot write to folder: {folderValidation.ErrorMessage}";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            ProgressValue = 0;
            StatusMessage = "Scanning tournaments...";
            StatusSeverity = InfoBarSeverity.Informational;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail(0);

            _cancellationTokenSource = new CancellationTokenSource();

            var progress = new Progress<double>(p =>
            {
                ProgressValue = p;
                StatusMessage = $"Breaking tournaments... {p:0}%";
                StatusDetail = BuildProgressDetail(p);
            });

            var tournaments = await _tourBreakerService.BreakTournamentsAsync(
                InputFilePath,
                OutputFolderPath,
                MinElo,
                MinGames,
                progress,
                _cancellationTokenSource.Token);

            ProgressValue = 100;
            StatusMessage = tournaments == 0
                ? "No tournaments matched the filters."
                : $"Done. Extracted {tournaments:N0} tournament(s).";
            StatusSeverity = tournaments == 0 ? InfoBarSeverity.Warning : InfoBarSeverity.Success;
            StatusDetail = BuildProgressDetail(100);
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "Tournament breaking cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            ProgressValue = 0;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
    }
    }

    private bool CanRun() =>
        !IsRunning &&
        !string.IsNullOrWhiteSpace(InputFilePath) &&
        !string.IsNullOrWhiteSpace(OutputFolderPath) &&
        File.Exists(InputFilePath);

    [RelayCommand]
    private void Cancel()
    {
        _cancellationTokenSource?.Cancel();
        StatusMessage = "Cancelling...";
        StatusSeverity = InfoBarSeverity.Warning;
        StatusDetail = BuildProgressDetail(ProgressValue);
    }
    partial void OnInputFilePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnOutputFolderPathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnIsRunningChanged(bool value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    public void Dispose()
    {
        if (_disposed)
        {
            return;
    }
        _disposed = true;
        SaveState();
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        _cancellationTokenSource = null;
        _executionLock.Dispose();
    }
    private void LoadState()
    {
        InputFilePath = _settings.GetValue($"{SettingsPrefix}.{nameof(InputFilePath)}", string.Empty);
        if (!string.IsNullOrWhiteSpace(InputFilePath) && File.Exists(InputFilePath))
        {
            InputFileName = Path.GetFileName(InputFilePath);
    }
        else
        {
            InputFilePath = string.Empty;
            InputFileName = string.Empty;
    }
        OutputFolderPath = _settings.GetValue($"{SettingsPrefix}.{nameof(OutputFolderPath)}", OutputFolderPath);
        OutputFolderName = string.IsNullOrWhiteSpace(OutputFolderPath)
            ? string.Empty
            : Path.GetFileName(OutputFolderPath.TrimEnd(Path.DirectorySeparatorChar));

        MinElo = _settings.GetValue($"{SettingsPrefix}.{nameof(MinElo)}", MinElo);
        MinGames = _settings.GetValue($"{SettingsPrefix}.{nameof(MinGames)}", MinGames);
    }
    private void SaveState()
    {
        _settings.SetValue($"{SettingsPrefix}.{nameof(InputFilePath)}", InputFilePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(OutputFolderPath)}", OutputFolderPath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(MinElo)}", MinElo);
        _settings.SetValue($"{SettingsPrefix}.{nameof(MinGames)}", MinGames);
    }
}






===== END: PgnTools\ViewModels\Tools\TourBreakerViewModel.cs =====

===== BEGIN: PgnTools\Views\Tools\TourBreakerPage.xaml =====
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="PgnTools.Views.Tools.TourBreakerPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:controls="using:PgnTools.Views.Controls"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d" NavigationCacheMode="Disabled">

    <Grid Padding="0,0,0,24">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <StackPanel Grid.Row="0" Spacing="8" Margin="0,0,0,24">
            <TextBlock Text="Tournament Breaker" Style="{StaticResource TitleTextBlockStyle}"/>
            <TextBlock Text="Split a large database into separate files per tournament, filtered by minimum Elo and game count."
                       Style="{StaticResource BodyTextBlockStyle}"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       TextWrapping="Wrap"/>
        </StackPanel>

        <!-- Inputs -->
        <StackPanel Grid.Row="1" Spacing="12" Margin="0,0,0,24">
            <TextBlock Text="Input File"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select input PGN..."
                         Text="{x:Bind ViewModel.InputFilePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectInputFileCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <TextBlock Text="Output Folder"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select output folder..."
                         Text="{x:Bind ViewModel.OutputFolderPath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectOutputFolderCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <StackPanel Orientation="Horizontal" Spacing="24">
                <StackPanel Spacing="6">
                    <TextBlock Text="Minimum Elo"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                    <NumberBox Width="180"
                               Minimum="0"
                               SmallChange="10"
                               SpinButtonPlacementMode="Inline"
                               Value="{x:Bind ViewModel.MinElo, Mode=TwoWay}"/>
                </StackPanel>

                <StackPanel Spacing="6">
                    <TextBlock Text="Minimum Games"
                               Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
                    <NumberBox Width="180"
                               Minimum="1"
                               SmallChange="1"
                               SpinButtonPlacementMode="Inline"
                               Value="{x:Bind ViewModel.MinGames, Mode=TwoWay}"/>
                </StackPanel>
            </StackPanel>

            <StackPanel Orientation="Horizontal" Spacing="12">
                <Button Content="Run"
                        Command="{x:Bind ViewModel.RunCommand}"
                        Style="{StaticResource PrimaryAction}"/>

                <Button Content="Cancel"
                        Command="{x:Bind ViewModel.CancelCommand}"
                        Style="{StaticResource Action}"
                        IsEnabled="{x:Bind ViewModel.IsRunning, Mode=OneWay}"/>
            </StackPanel>
        </StackPanel>

        <!-- Status -->
        <ScrollViewer Grid.Row="2" VerticalScrollBarVisibility="Auto">
            <controls:ToolStatusBar StatusMessage="{x:Bind ViewModel.StatusMessage, Mode=OneWay}"
                                    StatusSeverity="{x:Bind ViewModel.StatusSeverity, Mode=OneWay}"
                                    StatusDetail="{x:Bind ViewModel.StatusDetail, Mode=OneWay}"
                                    IsRunning="{x:Bind ViewModel.IsRunning, Mode=OneWay}"
                                    IsIndeterminate="False"
                                    ProgressValue="{x:Bind ViewModel.ProgressValue, Mode=OneWay}"/>
        </ScrollViewer>
    </Grid>
</Page>








===== END: PgnTools\Views\Tools\TourBreakerPage.xaml =====

===== BEGIN: PgnTools\Views\Tools\TourBreakerPage.xaml.cs =====
namespace PgnTools.Views.Tools;

/// <summary>
/// Page for the Tournament Breaker tool.
/// </summary>
public sealed partial class TourBreakerPage : Page
{
    private readonly bool _ownsViewModel;
    public TourBreakerViewModel ViewModel { get; }

    public TourBreakerPage() : this(App.GetService<TourBreakerViewModel>(), ownsViewModel: true)
    {
    }

    public TourBreakerPage(TourBreakerViewModel viewModel, bool ownsViewModel = false)
    {
        ViewModel = viewModel ?? throw new System.ArgumentNullException(nameof(viewModel));
        _ownsViewModel = ownsViewModel;
        this.InitializeComponent();
    }

    protected override void OnNavigatedFrom(NavigationEventArgs e)
    {
        base.OnNavigatedFrom(e);
        if (_ownsViewModel)
        {
            if (ViewModel.IsRunning)
            {
                ViewModel.CancelCommand.Execute(null);
            }
            else
            {
                ViewModel.Dispose();
            }
        }
    }
}


===== END: PgnTools\Views\Tools\TourBreakerPage.xaml.cs =====


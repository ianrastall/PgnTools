# Context Dump: Analyzer + Elegance
# Date: 2026-02-07 12:06:41
# File Count: 16

===== BEGIN: Docs\ChessAnalyzerService.md =====
# ChessAnalyzerService.md

## Service Implementations: ChessAnalyzerService and EleganceService

**Version:** Current implementation (updated 2026-02-07)  
**Layer:** Service Layer (Domain Logic)  
**Dependencies:** `PgnReader`, `PgnWriter`, UCI engine executable, `Chess` (Gera.Chess), `EleganceScoreCalculator`, `FileReplacementHelper`, `StockfishDownloaderService`  
**Thread Safety:** Safe for concurrent calls with separate output paths and engine instances.

## 1. Objective

The Chess Analyzer tool has two closely related workflows:

- **ChessAnalyzerService**: analyze PGN games with a UCI engine, annotate each move with evaluations and NAGs, and optionally add Elegance tags.
- **EleganceService**: run the analyzer first, then compute Elegance component scores and add `Elegance` / `EleganceDetails` headers.

## 2. Public API (Actual)

```csharp
public interface IChessAnalyzerService
{
    Task AnalyzePgnAsync(
        string inputFilePath,
        string outputFilePath,
        string enginePath,
        int depth,
        string? tablebasePath,
        IProgress<AnalyzerProgress>? progress = null,
        CancellationToken cancellationToken = default,
        bool addEleganceTags = false);
}

public readonly record struct AnalyzerProgress(long ProcessedGames, long TotalGames, double Percent);

public interface IEleganceService
{
    Task<EleganceTaggerResult> TagEleganceAsync(
        string inputFilePath,
        string outputFilePath,
        string enginePath,
        int depth,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default);
}

public sealed record EleganceTaggerResult(
    long ProcessedGames,
    double AverageScore,
    double AverageSoundness,
    double AverageCoherence,
    double AverageTactical,
    double AverageQuiet);
```

## 3. High-Level Pipeline (Actual)

### ChessAnalyzerService

1. **Validate** input/output/engine paths and depth.
2. **Start UCI engine** and optionally set `SyzygyPath`.
3. **Stream PGN games**, analyze each move:
   - Parse SAN and generate FEN positions.
   - Query engine at the requested depth for each ply.
   - Insert NAGs and `[%eval ...]` comments into move text.
4. **Write output** to a temp file and replace the destination file.
5. **On per-game failure**, preserve original movetext and continue.

### EleganceService (Standalone Tagger)

1. **Analyze games** with `IChessAnalyzerService` into a temp analyzed PGN.
2. **Parse analyzed move text** and evaluation comments.
3. **Compute component scores** (Soundness, Coherence, Tactical, Quiet) and total Elegance.
4. **Write output** with `Elegance` and `EleganceDetails` headers.
5. **Replace** destination file and clean temp files.

## 4. Annotation Rules

- Adds NAGs based on centipawn delta for the mover:
  - `<= -300` → `$4` (blunder)
  - `<= -150` → `$2` (mistake)
  - `<= -60` → `$6` (inaccuracy/dubious)
- Adds an evaluation comment after each move:
  - `{ [%eval <score>] }` where `<score>` is centipawns or `#<mate>` for mate.
- Adds headers:
  - `Annotator = "PgnTools"`
  - `AnalysisDepth = <depth>`

## 5. Elegance Tags

When enabled or when using the Elegance tool, games receive:

- `Elegance` (0–100)
- `EleganceDetails` (component breakdown)

The scorer uses:

- `[%eval ...]` comments from the analyzer,
- NAGs and annotations,
- Material/forcing/quiet move heuristics,
- Distribution normalization from `Assets/elegance-distributions.json` (fallback defaults if missing).

## 6. Progress Reporting

- **ChessAnalyzerService** reports `AnalyzerProgress`:
  - `ProcessedGames` increments per game.
  - `Percent` is based on input stream position (bytes).
- **EleganceService** combines progress:
  - Analyzer progress weighted 70%.
  - Scoring progress weighted 30% (based on bytes read from analyzed PGN).

## 7. Related Tool Integration

The Chess Analyzer UI integrates the **Stockfish downloader** (`StockfishDownloaderService`) to fetch a UCI engine and locate a suitable executable automatically.

## 8. Limitations

- Requires a valid UCI engine executable path.
- Uses synchronous `ReplaceFile` at the end of the analyzer and elegance pipelines.
- Move annotation depends on SAN parsing; malformed move text can skip annotations for that game.
- Elegance scoring depends on analyzer output and temp-file processing.
===== END: Docs\ChessAnalyzerService.md =====

===== BEGIN: PgnTools\Helpers\FilePickerHelper.cs =====
using System.Collections.Generic;
using System.Linq;
using Windows.Storage;
using Windows.Storage.Pickers;

namespace PgnTools.Helpers;

/// <summary>
/// Helper class for file/folder pickers in WinUI 3 Unpackaged apps.
/// Handles the IInitializeWithWindow pattern required for unpackaged apps.
/// </summary>
public static class FilePickerHelper
{
    /// <summary>
    /// Opens a file picker to select a single file.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <param name="fileTypeFilters">File type filters (e.g., ".pgn", ".txt").</param>
    /// <returns>The selected StorageFile, or null if cancelled.</returns>
    public static async Task<StorageFile?> PickSingleFileAsync(
        nint windowHandle,
        string? settingsIdentifier,
        params string[] fileTypeFilters)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileOpenPicker();

        // Initialize with window handle for unpackaged apps
        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var addedFilter = false;
        foreach (var filter in NormalizeFilters(fileTypeFilters))
        {
            picker.FileTypeFilter.Add(filter);
            addedFilter = true;
        }

        if (!addedFilter)
        {
            picker.FileTypeFilter.Add("*");
        }

        return await picker.PickSingleFileAsync();
    }

    /// <summary>
    /// Opens a file picker to select multiple files.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <param name="fileTypeFilters">File type filters (e.g., ".pgn", ".txt").</param>
    /// <returns>The selected StorageFiles, or empty if cancelled.</returns>
    public static async Task<IReadOnlyList<StorageFile>> PickMultipleFilesAsync(
        nint windowHandle,
        string? settingsIdentifier,
        params string[] fileTypeFilters)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileOpenPicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var addedFilter = false;
        foreach (var filter in NormalizeFilters(fileTypeFilters))
        {
            picker.FileTypeFilter.Add(filter);
            addedFilter = true;
        }

        if (!addedFilter)
        {
            picker.FileTypeFilter.Add("*");
        }

        return await picker.PickMultipleFilesAsync();
    }

    /// <summary>
    /// Opens a file picker to save a file.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="suggestedFileName">Suggested file name.</param>
    /// <param name="fileTypeChoices">Dictionary of file type descriptions to extensions.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <returns>The selected StorageFile, or null if cancelled.</returns>
    public static async Task<StorageFile?> PickSaveFileAsync(
        nint windowHandle,
        string suggestedFileName,
        Dictionary<string, IList<string>> fileTypeChoices,
        string? settingsIdentifier = null)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileSavePicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        picker.SuggestedFileName = suggestedFileName;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var normalizedChoices = new List<(string Label, List<string> Extensions)>();
        foreach (var choice in fileTypeChoices)
        {
            var normalizedExtensions = NormalizeFilters(choice.Value).ToList();
            if (normalizedExtensions.Count == 0)
            {
                continue;
            }

            normalizedChoices.Add((choice.Key, normalizedExtensions));
            picker.FileTypeChoices.Add(choice.Key, normalizedExtensions);
        }

        if (string.IsNullOrWhiteSpace(picker.DefaultFileExtension))
        {
            foreach (var choice in normalizedChoices)
            {
                var extension = choice.Extensions[0];
                if (!string.IsNullOrWhiteSpace(extension))
                {
                    picker.DefaultFileExtension = extension.StartsWith(".", StringComparison.Ordinal)
                        ? extension
                        : $".{extension}";
                    break;
                }
            }
        }

        return await picker.PickSaveFileAsync();
    }

    /// <summary>
    /// Opens a folder picker to select a folder.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <returns>The selected StorageFolder, or null if cancelled.</returns>
    public static async Task<StorageFolder?> PickFolderAsync(nint windowHandle, string? settingsIdentifier = null)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FolderPicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        picker.FileTypeFilter.Add("*");
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        return await picker.PickSingleFolderAsync();
    }

    private static void ValidateWindowHandle(nint windowHandle)
    {
        if (windowHandle == 0)
        {
            throw new ArgumentException("Window handle (HWND) cannot be zero.", nameof(windowHandle));
        }
    }

    private static IEnumerable<string> NormalizeFilters(IEnumerable<string> filters)
    {
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var filter in filters)
        {
            if (string.IsNullOrWhiteSpace(filter))
            {
                continue;
            }

            var trimmed = filter.Trim();
            var normalized = trimmed == "*"
                ? "*"
                : trimmed.StartsWith(".", StringComparison.Ordinal)
                    ? trimmed
                    : $".{trimmed}";

            if (seen.Add(normalized))
            {
                yield return normalized;
            }
        }
    }
}
===== END: PgnTools\Helpers\FilePickerHelper.cs =====

===== BEGIN: PgnTools\Helpers\FileReplacementHelper.cs =====
// PGNTOOLS-TABLEBASES-BEGIN
using System.IO;

namespace PgnTools.Helpers;

public static class FileReplacementHelper
{
    private const int MaxReplaceAttempts = 6;

    public static string CreateTempFilePath(string destinationPath)
    {
        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        var directory = Path.GetDirectoryName(destinationPath);
        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.GetTempPath();
        }

        var fileName = Path.GetFileName(destinationPath);
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "output";
        }

        var tempName = $".{fileName}.{Guid.NewGuid():N}.tmp";
        return Path.Combine(directory, tempName);
    }

    public static void ReplaceFile(string tempFilePath, string destinationPath)
    {
        if (string.IsNullOrWhiteSpace(tempFilePath))
        {
            throw new ArgumentException("Temp file path is required.", nameof(tempFilePath));
        }

        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        if (!File.Exists(tempFilePath))
        {
            throw new FileNotFoundException("Temp file not found.", tempFilePath);
        }

        if (Path.GetDirectoryName(destinationPath) is { Length: > 0 } directory)
        {
            Directory.CreateDirectory(directory);
        }

        Exception? lastError = null;
        for (var attempt = 1; attempt <= MaxReplaceAttempts; attempt++)
        {
            try
            {
                var backupPath = CreateBackupPath(destinationPath);
                try
                {
                    File.Replace(tempFilePath, destinationPath, backupPath, ignoreMetadataErrors: true);
                    TryDeleteBackup(backupPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    File.Move(tempFilePath, destinationPath, overwrite: true);
                    return;
                }
            }
            catch (IOException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                Thread.Sleep(attempt * 100);
            }
            catch (UnauthorizedAccessException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                Thread.Sleep(attempt * 100);
            }
        }

        throw new IOException(
            $"Failed to replace '{destinationPath}' after {MaxReplaceAttempts} attempts. The file may be locked by another process.",
            lastError);
    }

    public static async Task ReplaceFileAsync(string tempFilePath, string destinationPath, CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(tempFilePath))
        {
            throw new ArgumentException("Temp file path is required.", nameof(tempFilePath));
        }

        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        if (!File.Exists(tempFilePath))
        {
            throw new FileNotFoundException("Temp file not found.", tempFilePath);
        }

        if (Path.GetDirectoryName(destinationPath) is { Length: > 0 } directory)
        {
            Directory.CreateDirectory(directory);
        }

        Exception? lastError = null;
        for (var attempt = 1; attempt <= MaxReplaceAttempts; attempt++)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                var backupPath = CreateBackupPath(destinationPath);
                try
                {
                    File.Replace(tempFilePath, destinationPath, backupPath, ignoreMetadataErrors: true);
                    TryDeleteBackup(backupPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    File.Move(tempFilePath, destinationPath, overwrite: true);
                    return;
                }
            }
            catch (IOException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                await Task.Delay(attempt * 100, ct).ConfigureAwait(false);
            }
            catch (UnauthorizedAccessException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                await Task.Delay(attempt * 100, ct).ConfigureAwait(false);
            }
        }

        throw new IOException(
            $"Failed to replace '{destinationPath}' after {MaxReplaceAttempts} attempts. The file may be locked by another process.",
            lastError);
    }

    private static string CreateBackupPath(string destinationPath)
    {
        var directory = Path.GetDirectoryName(destinationPath);
        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.GetTempPath();
        }

        var fileName = Path.GetFileName(destinationPath);
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "output";
        }

        var backupName = $".{fileName}.{Guid.NewGuid():N}.bak";
        return Path.Combine(directory, backupName);
    }

    private static void TryDeleteBackup(string backupPath)
    {
        try
        {
            if (File.Exists(backupPath))
            {
                File.Delete(backupPath);
            }
        }
        catch
        {
        }
    }
}
// PGNTOOLS-TABLEBASES-END
===== END: PgnTools\Helpers\FileReplacementHelper.cs =====

===== BEGIN: PgnTools\Helpers\FileValidationHelper.cs =====
// PGNTOOLS-TABLEBASES-BEGIN
using System.IO;
using Windows.Storage;

namespace PgnTools.Helpers;

/// <summary>
/// Helpers for validating file and folder access selected via pickers.
/// </summary>
public static class FileValidationHelper
{
    public static async Task<(bool Success, string? ErrorMessage)> ValidateReadableFileAsync(StorageFile file)
    {
        try
        {
            using var stream = await file.OpenReadAsync();
            return (true, null);
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }

    public static async Task<(bool Success, string? ErrorMessage)> ValidateWritableFolderAsync(string folderPath)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(folderPath))
            {
                return (false, "Folder path is empty.");
            }

            Directory.CreateDirectory(folderPath);

            var testFile = Path.Combine(folderPath, $".pgn_tools_write_{Guid.NewGuid():N}");
            await File.WriteAllTextAsync(testFile, "test");
            File.Delete(testFile);

            return (true, null);
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }
}
// PGNTOOLS-TABLEBASES-END
===== END: PgnTools\Helpers\FileValidationHelper.cs =====

===== BEGIN: PgnTools\Helpers\PgnHeaderExtensions.cs =====
namespace PgnTools.Helpers;

public static class PgnHeaderExtensions
{
    public static bool TryGetHeaderValue(
        this IReadOnlyDictionary<string, string> headers,
        string key,
        out string value)
    {
        if (headers == null)
        {
            throw new ArgumentNullException(nameof(headers));
        }

        if (string.IsNullOrEmpty(key))
        {
            value = string.Empty;
            return false;
        }

        if (headers.TryGetValue(key, out var found))
        {
            value = found ?? string.Empty;
            return true;
        }

        foreach (var header in headers)
        {
            if (string.Equals(header.Key, key, StringComparison.OrdinalIgnoreCase))
            {
                value = header.Value;
                return true;
            }
        }

        value = string.Empty;
        return false;
    }

    public static string? GetHeaderValueOrDefault(
        this IReadOnlyDictionary<string, string> headers,
        string key)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : null;
    }

    public static string GetHeaderValueOrDefault(
        this IReadOnlyDictionary<string, string> headers,
        string key,
        string defaultValue)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : defaultValue;
    }

    public static bool TryGetHeaderValue(
        this IReadOnlyList<KeyValuePair<string, string>> headers,
        string key,
        out string value)
    {
        if (headers == null)
        {
            throw new ArgumentNullException(nameof(headers));
        }

        if (string.IsNullOrEmpty(key))
        {
            value = string.Empty;
            return false;
        }

        for (var i = headers.Count - 1; i >= 0; i--)
        {
            var header = headers[i];
            if (string.Equals(header.Key, key, StringComparison.OrdinalIgnoreCase))
            {
                value = header.Value;
                return true;
            }
        }

        value = string.Empty;
        return false;
    }

    public static string? GetHeaderValueOrDefault(
        this IReadOnlyList<KeyValuePair<string, string>> headers,
        string key)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : null;
    }

    public static string GetHeaderValueOrDefault(
        this IReadOnlyList<KeyValuePair<string, string>> headers,
        string key,
        string defaultValue)
    {
        return headers.TryGetHeaderValue(key, out var value) ? value : defaultValue;
    }
}
===== END: PgnTools\Helpers\PgnHeaderExtensions.cs =====

===== BEGIN: PgnTools\Services\ChessAnalyzerService.cs =====
using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Channels;
using Chess;
using PgnTools.Helpers;

namespace PgnTools.Services;

public interface IChessAnalyzerService
{
    Task AnalyzePgnAsync(
        string inputFilePath,
        string outputFilePath,
        string enginePath,
        int depth,
        string? tablebasePath,
        IProgress<AnalyzerProgress>? progress = null,
        CancellationToken cancellationToken = default,
        bool addEleganceTags = false);
}

public readonly record struct AnalyzerProgress(long ProcessedGames, long TotalGames, double Percent);

internal readonly record struct EngineScore(int Centipawns, bool IsMate, int MateIn)
{
    public static EngineScore FromCentipawns(int cp) => new(cp, false, 0);
    public static EngineScore FromMate(int mateIn, int cpEquivalent) => new(cpEquivalent, true, mateIn);
}

/// <summary>
/// Performs engine-based analysis of PGN games.
/// </summary>
/// <remarks>
/// This implementation uses the Gera.Chess library to parse SAN moves and generate FEN
/// positions for a UCI engine (e.g., Stockfish).
/// </remarks>
public sealed class ChessAnalyzerService : IChessAnalyzerService
{
    private const int BufferSize = 65536;
    private const int BlunderThresholdCp = -300;
    private const int MistakeThresholdCp = -150;
    private const int InaccuracyThresholdCp = -60;

    private readonly PgnReader _pgnReader;
    private readonly PgnWriter _pgnWriter;

    private readonly record struct PgnToken(int Start, int Length, bool IsMove, string? San);
    private readonly record struct AnalyzedGameResult(string MoveText, EleganceScore? Elegance);

    public ChessAnalyzerService(PgnReader pgnReader, PgnWriter pgnWriter)
    {
        _pgnReader = pgnReader;
        _pgnWriter = pgnWriter;
    }

    public async Task AnalyzePgnAsync(
        string inputFilePath,
        string outputFilePath,
        string enginePath,
        int depth,
        string? tablebasePath,
        IProgress<AnalyzerProgress>? progress = null,
        CancellationToken cancellationToken = default,
        bool addEleganceTags = false)
    {
        if (string.IsNullOrWhiteSpace(inputFilePath))
        {
            throw new ArgumentException("Input file path is required.", nameof(inputFilePath));
        }

        if (string.IsNullOrWhiteSpace(outputFilePath))
        {
            throw new ArgumentException("Output file path is required.", nameof(outputFilePath));
        }

        if (string.IsNullOrWhiteSpace(enginePath))
        {
            throw new ArgumentException("Engine path is required.", nameof(enginePath));
        }

        if (depth <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(depth), "Depth must be greater than zero.");
        }

        var inputFullPath = Path.GetFullPath(inputFilePath);
        var outputFullPath = Path.GetFullPath(outputFilePath);
        var engineFullPath = Path.GetFullPath(enginePath);
        var tempOutputPath = FileReplacementHelper.CreateTempFilePath(outputFullPath);

        if (!File.Exists(inputFullPath))
        {
            throw new FileNotFoundException("Input PGN file not found.", inputFullPath);
        }

        if (!File.Exists(engineFullPath))
        {
            throw new FileNotFoundException("UCI engine not found.", engineFullPath);
        }

        if (string.Equals(inputFullPath, outputFullPath, StringComparison.OrdinalIgnoreCase))
        {
            throw new InvalidOperationException("Input and output files must be different.");
        }

        var outputDirectory = Path.GetDirectoryName(outputFullPath);
        if (!string.IsNullOrWhiteSpace(outputDirectory))
        {
            Directory.CreateDirectory(outputDirectory);
        }

        try
        {
            var totalGames = 0L;
            var processedGames = 0L;
            var analyzedGames = 0L;
            var failedGames = 0L;
            string? firstFailureMessage = null;

            UciEngine? engine = null;
            var cancellationRegistration = default(CancellationTokenRegistration);

            async Task<UciEngine> StartEngineAsync()
            {
                var newEngine = new UciEngine(engineFullPath);
                try
                {
                    await newEngine.StartAsync(cancellationToken).ConfigureAwait(false);
                    if (!string.IsNullOrWhiteSpace(tablebasePath))
                    {
                        await newEngine.SetOptionAsync("SyzygyPath", tablebasePath, cancellationToken)
                            .ConfigureAwait(false);
                    }

                    cancellationRegistration.Dispose();
                    cancellationRegistration = cancellationToken.Register(newEngine.RequestAbort);
                    return newEngine;
                }
                catch
                {
                    newEngine.Dispose();
                    throw;
                }
            }

            try
            {
                await using var inputStream = new FileStream(
                    inputFullPath,
                    FileMode.Open,
                    FileAccess.Read,
                    FileShare.Read,
                    BufferSize,
                    FileOptions.SequentialScan | FileOptions.Asynchronous);
                var totalBytes = inputStream.CanSeek ? inputStream.Length : 0L;

                await using (var outputStream = new FileStream(
                    tempOutputPath,
                    FileMode.Create,
                    FileAccess.Write,
                    FileShare.None,
                    BufferSize,
                    FileOptions.SequentialScan | FileOptions.Asynchronous))
                using (var writer = new StreamWriter(outputStream, new UTF8Encoding(false), BufferSize, leaveOpen: true))
                {
                    engine = await StartEngineAsync().ConfigureAwait(false);
                    var needsReadyAfterNewGame = true;

                    var firstOutput = true;
                    progress?.Report(new AnalyzerProgress(0, totalGames, 0));

                    await foreach (var game in _pgnReader.ReadGamesAsync(inputStream, cancellationToken)
                                       .ConfigureAwait(false))
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        processedGames++;
                        var currentEngine = engine ?? throw new InvalidOperationException("UCI engine is not initialized.");
                        var waitForReady = needsReadyAfterNewGame;

                        try
                        {
                            await Task.Run(async () =>
                            {
                                await currentEngine.NewGameAsync(cancellationToken, waitForReady).ConfigureAwait(false);
                                var analysis = await AnalyzeGameAsync(game, currentEngine, depth, addEleganceTags, cancellationToken)
                                    .ConfigureAwait(false);

                                game.MoveText = analysis.MoveText;
                                cancellationToken.ThrowIfCancellationRequested();
                                game.Headers["Annotator"] = "PgnTools";
                                game.Headers["AnalysisDepth"] = depth.ToString(CultureInfo.InvariantCulture);

                                if (addEleganceTags && analysis.Elegance.HasValue)
                                {
                                    var elegance = analysis.Elegance.Value;
                                    game.Headers["Elegance"] = elegance.Score.ToString(CultureInfo.InvariantCulture);
                                    game.Headers["EleganceDetails"] = EleganceScoreCalculator.FormatDetails(elegance);
                                }
                            }, cancellationToken).ConfigureAwait(false);

                            if (waitForReady)
                            {
                                needsReadyAfterNewGame = false;
                            }

                            analyzedGames++;
                        }
                        catch (OperationCanceledException)
                        {
                            throw;
                        }
                        catch (Exception ex)
                        {
                            failedGames++;
                            firstFailureMessage ??= $"Game #{processedGames}: {ex.GetType().Name}: {ex.Message}";

                            if (engine != null && engine.HasExited)
                            {
                                engine.Dispose();
                                engine = await StartEngineAsync().ConfigureAwait(false);
                                needsReadyAfterNewGame = true;
                            }

                            // If analysis fails for a given game, preserve the original movetext
                            // and continue processing the rest of the file.
                        }

                        if (!firstOutput)
                        {
                            await writer.WriteLineAsync().ConfigureAwait(false);
                        }

                        await _pgnWriter.WriteGameAsync(writer, game, cancellationToken).ConfigureAwait(false);
                        firstOutput = false;

                        var percent = totalBytes > 0 && inputStream.CanSeek
                            ? Math.Clamp(inputStream.Position / (double)totalBytes * 100.0, 0, 100)
                            : 0d;
                        progress?.Report(new AnalyzerProgress(processedGames, totalGames, percent));
                    }

                    await writer.FlushAsync().ConfigureAwait(false);
                }

                if (analyzedGames == 0 && failedGames > 0)
                {
                    throw new InvalidOperationException(
                        $"No games could be analyzed. First failure: {firstFailureMessage ?? "Unknown move parsing error."}");
                }

                FileReplacementHelper.ReplaceFile(tempOutputPath, outputFullPath);
                progress?.Report(new AnalyzerProgress(processedGames, totalGames, 100));
            }
            finally
            {
                cancellationRegistration.Dispose();
                engine?.Dispose();
            }
        }
        catch
        {
            if (File.Exists(tempOutputPath))
            {
                try
                {
                    File.Delete(tempOutputPath);
                }
                catch
                {
                }
            }

            throw;
        }
    }

    private static readonly Regex MoveNumberPrefixRegex = new(
        @"^(?<num>\d+)\.(?:\.\.)?(?<rest>.*)$",
        RegexOptions.Compiled);

    private static readonly Regex MoveNumberOnlyRegex = new(
        @"^\d+\.(?:\.\.)?$",
        RegexOptions.Compiled);

    private static readonly Regex NagRegex = new(
        @"^\$\d+$",
        RegexOptions.Compiled);

    private static readonly Regex InlineNagRegex = new(
        @"\$\d+",
        RegexOptions.Compiled);

    private static readonly Regex CoordinateMoveRegex = new(
        @"^(?<piece>[KQRBNP])?(?<from>[a-h][1-8])(?:[-x:]?)(?<to>[a-h][1-8])(?:=?(?<promo>[QRBN]))?$",
        RegexOptions.Compiled | RegexOptions.IgnoreCase);

    private static readonly HashSet<string> ResultTokens =
    [
        "1-0",
        "0-1",
        "1/2-1/2",
        "*"
    ];

    private async Task<AnalyzedGameResult> AnalyzeGameAsync(
        PgnGame game,
        UciEngine engine,
        int depth,
        bool addEleganceTags,
        CancellationToken cancellationToken)
    {
        var board = CreateBoardFromHeaders(game.Headers);
        var moveText = game.MoveText;
        var tokens = TokenizeMoveTextPreserving(moveText);

        if (tokens.Count == 0 || tokens.TrueForAll(token => !token.IsMove))
        {
            return new AnalyzedGameResult(game.MoveText, null);
        }

        var builder = new StringBuilder(game.MoveText.Length + tokens.Count * 24);
        var fenBefore = board.ToFen();
        var scoreBefore = await engine.AnalyzeAsync(fenBefore, depth, cancellationToken).ConfigureAwait(false);
        cancellationToken.ThrowIfCancellationRequested();

        var metrics = addEleganceTags ? new RunningEleganceMetrics() : default;
        var whiteMaterialBefore = 0;
        var blackMaterialBefore = 0;
        if (addEleganceTags)
        {
            ComputeMaterialTotalsCp(fenBefore, out whiteMaterialBefore, out blackMaterialBefore);
        }

        foreach (var token in tokens)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var tokenSpan = moveText.AsSpan(token.Start, token.Length);
            if (!token.IsMove)
            {
                builder.Append(tokenSpan);
                continue;
            }

            var tokenText = tokenSpan.ToString();
            if (string.IsNullOrWhiteSpace(token.San))
            {
                throw new InvalidOperationException($"Unable to parse move token: {tokenText}");
            }

            var moverSide = board.Turn;
            if (!TryResolveMoveNotation(board, token.San, out var resolvedSan))
            {
                throw new InvalidOperationException(
                    $"Unsupported move notation '{token.San}' in token '{tokenText}'.");
            }

            var hasCapture = resolvedSan.IndexOf('x') >= 0;
            var hasCheck = resolvedSan.IndexOf('+') >= 0;
            var hasMate = resolvedSan.IndexOf('#') >= 0;
            var hasPromotion = resolvedSan.IndexOf('=') >= 0;
            var isQuiet = !hasCapture && !hasCheck && !hasMate && !hasPromotion;

            // Apply the move. If this throws, the caller will preserve original movetext.
            if (!board.Move(resolvedSan))
            {
                throw new InvalidOperationException(
                    $"Failed to apply move '{resolvedSan}' parsed from token '{tokenText}'.");
            }

            var fenAfter = board.ToFen();
            var scoreAfter = await engine.AnalyzeAsync(fenAfter, depth, cancellationToken).ConfigureAwait(false);
            cancellationToken.ThrowIfCancellationRequested();

            var deltaCp = ComputeDeltaForMover(scoreBefore, scoreAfter);
            var nag = GetNagForDelta(deltaCp);

            var sideToMoveAfter = board.Turn;
            var afterWhite = ToWhitePerspective(scoreAfter, sideToMoveAfter);
            var evalText = FormatEval(afterWhite);

            var annotatedMove = BuildAnnotatedMove(tokenText, nag, evalText);
            builder.Append(annotatedMove);

            if (addEleganceTags)
            {
                metrics.PlyCount++;
                metrics.EvaluatedPlyCount++;

                ComputeMaterialTotalsCp(fenAfter, out var whiteMaterialAfter, out var blackMaterialAfter);

                var whiteMaterialLossCp = whiteMaterialBefore - whiteMaterialAfter;
                if (whiteMaterialLossCp > 0)
                {
                    UpdateSacrificeMetrics(
                        PieceColor.White,
                        whiteMaterialLossCp,
                        scoreBefore,
                        moverSide,
                        scoreAfter,
                        sideToMoveAfter,
                        ref metrics);
                }

                var blackMaterialLossCp = blackMaterialBefore - blackMaterialAfter;
                if (blackMaterialLossCp > 0)
                {
                    UpdateSacrificeMetrics(
                        PieceColor.Black,
                        blackMaterialLossCp,
                        scoreBefore,
                        moverSide,
                        scoreAfter,
                        sideToMoveAfter,
                        ref metrics);
                }

                whiteMaterialBefore = whiteMaterialAfter;
                blackMaterialBefore = blackMaterialAfter;

                if (hasCapture || hasCheck || hasMate || hasPromotion)
                {
                    metrics.ForcingMoveCount++;
                }

                if (deltaCp <= BlunderThresholdCp)
                {
                    metrics.BlunderCount++;
                }
                else if (deltaCp <= MistakeThresholdCp)
                {
                    metrics.MistakeCount++;
                }
                else if (deltaCp <= InaccuracyThresholdCp)
                {
                    metrics.DubiousCount++;
                }

                if (isQuiet && deltaCp >= 150)
                {
                    metrics.QuietImprovementCount++;
                }

                var evalWhiteCp = afterWhite.Centipawns;
                if (metrics.PreviousEvalWhiteCp.HasValue)
                {
                    metrics.SwingAbsSum += Math.Abs(evalWhiteCp - metrics.PreviousEvalWhiteCp.Value);
                    metrics.SwingCount++;
                }

                metrics.PreviousEvalWhiteCp = evalWhiteCp;

                metrics.MoverDeltaSum += deltaCp;
                metrics.MoverDeltaSquareSum += deltaCp * (double)deltaCp;
                metrics.MoverDeltaCount++;

                var evalForMoverSide = moverSide == PieceColor.White ? evalWhiteCp : -evalWhiteCp;
                if (moverSide == PieceColor.White)
                {
                    UpdateTrendMetrics(
                        evalForMoverSide,
                        ref metrics.WhiteLastEval,
                        ref metrics.WhitePreviousDelta,
                        ref metrics.TrendBreakCount);
                }
                else
                {
                    UpdateTrendMetrics(
                        evalForMoverSide,
                        ref metrics.BlackLastEval,
                        ref metrics.BlackPreviousDelta,
                        ref metrics.TrendBreakCount);
                }
            }

            // After the move, the engine evaluation is from the perspective of the
            // next side to move, which is exactly the "before" score for the next ply.
            scoreBefore = scoreAfter;
            fenBefore = fenAfter;
        }

        if (!ContainsResultToken(tokens, moveText))
        {
            var result = game.Headers.GetHeaderValueOrDefault("Result", "*");
            if (!string.IsNullOrWhiteSpace(result))
            {
                if (builder.Length > 0 && !char.IsWhiteSpace(builder[^1]))
                {
                    builder.Append(' ');
                }

                builder.Append(result);
            }
        }

        EleganceScore? elegance = null;
        if (addEleganceTags && metrics.PlyCount > 0)
        {
            var forcingPercent = metrics.PlyCount > 0
                ? metrics.ForcingMoveCount * 100d / metrics.PlyCount
                : 0d;

            var averageAbsSwing = metrics.SwingCount > 0
                ? metrics.SwingAbsSum / metrics.SwingCount
                : 350d;

            var evalStdDev = 220d;
            if (metrics.MoverDeltaCount > 0)
            {
                var mean = metrics.MoverDeltaSum / metrics.MoverDeltaCount;
                var variance = (metrics.MoverDeltaSquareSum / metrics.MoverDeltaCount) - (mean * mean);
                evalStdDev = Math.Sqrt(Math.Max(0d, variance));
            }

            var eleganceMetrics = new EleganceEvaluationMetrics(
                metrics.PlyCount,
                metrics.EvaluatedPlyCount,
                forcingPercent,
                metrics.QuietImprovementCount,
                metrics.TrendBreakCount,
                metrics.BlunderCount,
                metrics.MistakeCount,
                metrics.DubiousCount,
                averageAbsSwing,
                evalStdDev,
                metrics.SoundSacrificeCount,
                metrics.UnsoundSacrificeCount,
                metrics.SoundSacrificeCp,
                metrics.UnsoundSacrificeCp);

            elegance = EleganceScoreCalculator.Calculate(eleganceMetrics);
        }

        return new AnalyzedGameResult(builder.ToString(), elegance);
    }

    private static ChessBoard CreateBoardFromHeaders(IReadOnlyDictionary<string, string> headers)
    {
        if (headers.TryGetHeaderValue("FEN", out var fen) && !string.IsNullOrWhiteSpace(fen))
        {
            try
            {
                return ChessBoard.LoadFromFen(fen);
            }
            catch
            {
                // Fall back to default start position on invalid FEN.
            }
        }

        return new ChessBoard();
    }

    private static bool ContainsResultToken(List<PgnToken> tokens, string moveText)
    {
        foreach (var token in tokens)
        {
            if (token.IsMove)
            {
                continue;
            }

            var trimmed = moveText.AsSpan(token.Start, token.Length).Trim();
            if (trimmed.Length == 0)
            {
                continue;
            }

            foreach (var result in ResultTokens)
            {
                if (trimmed.Equals(result, StringComparison.Ordinal))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private static string BuildAnnotatedMove(string san, string? nag, string evalText)
    {
        var sb = new StringBuilder(san.Length + 24);
        sb.Append(san);

        if (!string.IsNullOrWhiteSpace(nag))
        {
            sb.Append(' ').Append(nag);
        }

        sb.Append(" { [%eval ").Append(evalText).Append("] }");
        return sb.ToString();
    }

    private static int ComputeDeltaForMover(EngineScore before, EngineScore after)
    {
        // The engine score is from the perspective of the side to move.
        // After making a move, the engine evaluates from the opponent's perspective,
        // so we invert the sign to get the mover's perspective again.
        var afterForMover = -after.Centipawns;
        return afterForMover - before.Centipawns;
    }

    private static void UpdateSacrificeMetrics(
        PieceColor sideLosingMaterial,
        int materialLossCp,
        EngineScore scoreBefore,
        PieceColor sideToMoveBefore,
        EngineScore scoreAfter,
        PieceColor sideToMoveAfter,
        ref RunningEleganceMetrics metrics)
    {
        // Ignore tiny losses (for example, transient rounding or malformed data).
        if (materialLossCp < 100)
        {
            return;
        }

        var evalBeforeForLosingSide = ToPerspectiveCentipawns(scoreBefore, sideLosingMaterial, sideToMoveBefore);
        var evalAfterForLosingSide = ToPerspectiveCentipawns(scoreAfter, sideLosingMaterial, sideToMoveAfter);
        var evalDeltaForLosingSide = evalAfterForLosingSide - evalBeforeForLosingSide;

        var maxAllowedDrop = materialLossCp switch
        {
            >= 500 => -140,
            >= 300 => -120,
            _ => -90
        };

        var absoluteFloor = materialLossCp switch
        {
            >= 500 => -220,
            >= 300 => -180,
            _ => -140
        };

        if (evalAfterForLosingSide >= absoluteFloor && evalDeltaForLosingSide >= maxAllowedDrop)
        {
            metrics.SoundSacrificeCount++;
            metrics.SoundSacrificeCp += materialLossCp;
        }
        else
        {
            metrics.UnsoundSacrificeCount++;
            metrics.UnsoundSacrificeCp += materialLossCp;
        }
    }

    private static int ToPerspectiveCentipawns(EngineScore score, PieceColor perspective, PieceColor sideToMove)
    {
        var whitePerspective = ToWhitePerspective(score, sideToMove).Centipawns;
        return perspective == PieceColor.White ? whitePerspective : -whitePerspective;
    }

    private static void ComputeMaterialTotalsCp(string fen, out int whiteMaterialCp, out int blackMaterialCp)
    {
        whiteMaterialCp = 0;
        blackMaterialCp = 0;

        if (string.IsNullOrWhiteSpace(fen))
        {
            return;
        }

        var span = fen.AsSpan();
        var boardEnd = span.IndexOf(' ');
        if (boardEnd < 0)
        {
            boardEnd = span.Length;
        }

        foreach (var symbol in span[..boardEnd])
        {
            if (symbol == '/' || (symbol >= '1' && symbol <= '8'))
            {
                continue;
            }

            var value = GetPieceMaterialValueCp(symbol);
            if (value == 0)
            {
                continue;
            }

            if (char.IsUpper(symbol))
            {
                whiteMaterialCp += value;
            }
            else
            {
                blackMaterialCp += value;
            }
        }
    }

    private static int GetPieceMaterialValueCp(char piece) => piece switch
    {
        'P' or 'p' => 100,
        'N' or 'n' => 320,
        'B' or 'b' => 330,
        'R' or 'r' => 500,
        'Q' or 'q' => 900,
        _ => 0
    };

    private static void UpdateTrendMetrics(
        double evalForSide,
        ref double? lastEval,
        ref double? previousDelta,
        ref int trendBreakCount)
    {
        if (!lastEval.HasValue)
        {
            lastEval = evalForSide;
            return;
        }

        var delta1 = evalForSide - lastEval.Value;
        if (previousDelta.HasValue)
        {
            var previousSign = Math.Sign(previousDelta.Value);
            var currentSign = Math.Sign(delta1);
            var delta2 = delta1 - previousDelta.Value;

            if (previousSign != 0 &&
                currentSign != 0 &&
                previousSign != currentSign &&
                Math.Abs(delta2) >= 50d)
            {
                trendBreakCount++;
            }
        }

        previousDelta = delta1;
        lastEval = evalForSide;
    }

    private static string? GetNagForDelta(int deltaCp)
    {
        if (deltaCp <= BlunderThresholdCp)
        {
            return "$4"; // blunder
        }

        if (deltaCp <= MistakeThresholdCp)
        {
            return "$2"; // mistake
        }

        if (deltaCp <= InaccuracyThresholdCp)
        {
            return "$6"; // inaccuracy/dubious move
        }

        return null;
    }

    private static EngineScore ToWhitePerspective(EngineScore score, PieceColor sideToMove)
    {
        if (sideToMove == PieceColor.White)
        {
            return score;
        }

        return score.IsMate
            ? EngineScore.FromMate(-score.MateIn, -score.Centipawns)
            : EngineScore.FromCentipawns(-score.Centipawns);
    }

    private static string FormatEval(EngineScore score)
    {
        if (score.IsMate)
        {
            if (score.MateIn == 0)
            {
                return "#0";
            }

            return score.MateIn > 0
                ? $"#{score.MateIn}"
                : $"#-{Math.Abs(score.MateIn)}";
        }

        var pawns = score.Centipawns / 100.0;
        return pawns.ToString("0.00", CultureInfo.InvariantCulture);
    }

    private static string SanitizeSan(string san)
    {
        if (string.IsNullOrWhiteSpace(san))
        {
            return string.Empty;
        }

        var token = san.Trim();

        // Normalize castling that uses zeros.
        token = token
            .Replace("0-0-0", "O-O-O", StringComparison.Ordinal)
            .Replace("0-0", "O-O", StringComparison.Ordinal);

        // Remove trailing annotation markers like !, ?, !?, ?!, etc.
        while (token.Length > 0)
        {
            var last = token[^1];
            if (last is '!' or '?')
            {
                token = token[..^1];
                continue;
            }

            break;
        }

        return token;
    }

    private static bool TryResolveMoveNotation(ChessBoard board, string moveToken, out string resolvedSan)
    {
        resolvedSan = string.Empty;
        if (string.IsNullOrWhiteSpace(moveToken))
        {
            return false;
        }

        var candidate = moveToken.Trim();
        if (board.IsValidMove(candidate))
        {
            resolvedSan = candidate;
            return true;
        }

        candidate = TrimNonSanSuffixes(candidate);
        if (candidate.Length == 0)
        {
            return false;
        }

        if (board.IsValidMove(candidate))
        {
            resolvedSan = candidate;
            return true;
        }

        var match = CoordinateMoveRegex.Match(candidate);
        if (!match.Success)
        {
            return false;
        }

        var from = match.Groups["from"].Value;
        var to = match.Groups["to"].Value;
        var pieceGroup = match.Groups["piece"];
        var promoGroup = match.Groups["promo"];

        var expectedPieceChar = pieceGroup.Success
            ? char.ToLowerInvariant(pieceGroup.ValueSpan[0])
            : '\0';

        var expectedPromotionChar = promoGroup.Success
            ? char.ToLowerInvariant(promoGroup.ValueSpan[0])
            : '\0';

        foreach (var legalMove in board.Moves(allowAmbiguousCastle: true, generateSan: true))
        {
            if (!SquareEquals(legalMove.OriginalPosition, from) ||
                !SquareEquals(legalMove.NewPosition, to))
            {
                continue;
            }

            if (expectedPieceChar != '\0')
            {
                var movePieceChar = char.ToLowerInvariant(legalMove.Piece.Type.AsChar);
                if (expectedPieceChar != movePieceChar)
                {
                    continue;
                }
            }

            if (expectedPromotionChar != '\0')
            {
                if (!legalMove.IsPromotion)
                {
                    continue;
                }

                var promotionPiece = legalMove.Promotion;
                if (promotionPiece == null)
                {
                    continue;
                }

                var movePromotionChar = char.ToLowerInvariant(promotionPiece.Type.AsChar);
                if (expectedPromotionChar != movePromotionChar)
                {
                    continue;
                }
            }
            else if (legalMove.IsPromotion)
            {
                continue;
            }

            if (string.IsNullOrWhiteSpace(legalMove.San))
            {
                continue;
            }

            resolvedSan = legalMove.San;
            return true;
        }

        return false;
    }

    private static string TrimNonSanSuffixes(string token)
    {
        if (string.IsNullOrWhiteSpace(token))
        {
            return string.Empty;
        }

        var candidate = token.Trim();
        if (candidate.EndsWith("e.p.", StringComparison.OrdinalIgnoreCase))
        {
            candidate = candidate[..^4].TrimEnd();
        }
        else if (candidate.EndsWith("ep", StringComparison.OrdinalIgnoreCase))
        {
            candidate = candidate[..^2].TrimEnd();
        }

        while (candidate.Length > 0)
        {
            var last = candidate[^1];
            if (last is '+' or '#')
            {
                candidate = candidate[..^1].TrimEnd();
                continue;
            }

            break;
        }

        return candidate;
    }

    private static bool SquareEquals(Position position, string square)
    {
        return position.ToString().Equals(square, StringComparison.OrdinalIgnoreCase);
    }

    private static List<PgnToken> TokenizeMoveTextPreserving(string moveText)
    {
        var tokens = new List<PgnToken>();
        if (string.IsNullOrEmpty(moveText))
        {
            return tokens;
        }

        var variationDepth = 0;
        var tokenStart = 0;

        void FlushCurrent(int endIndex)
        {
            if (endIndex <= tokenStart)
            {
                return;
            }

            var span = moveText.AsSpan(tokenStart, endIndex - tokenStart);
            var isMove = false;
            string? san = null;

            if (variationDepth == 0 && TryParseMoveToken(span, out var parsedSan))
            {
                isMove = true;
                san = parsedSan;
            }

            tokens.Add(new PgnToken(tokenStart, endIndex - tokenStart, isMove, san));
        }

        var i = 0;
        while (i < moveText.Length)
        {
            var c = moveText[i];

            if (c == '{')
            {
                FlushCurrent(i);
                var start = i;
                i++;
                while (i < moveText.Length && moveText[i] != '}')
                {
                    i++;
                }

                if (i < moveText.Length)
                {
                    i++;
                }

                tokens.Add(new PgnToken(start, i - start, false, null));
                tokenStart = i;
                continue;
            }

            if (c == ';')
            {
                FlushCurrent(i);
                var start = i;
                i++;
                while (i < moveText.Length)
                {
                    var cc = moveText[i];
                    if (cc == '\r')
                    {
                        i++;
                        if (i < moveText.Length && moveText[i] == '\n')
                        {
                            i++;
                        }

                        break;
                    }

                    if (cc == '\n')
                    {
                        i++;
                        break;
                    }

                    i++;
                }

                tokens.Add(new PgnToken(start, i - start, false, null));
                tokenStart = i;
                continue;
            }

            if (char.IsWhiteSpace(c))
            {
                FlushCurrent(i);
                var start = i;
                i++;
                while (i < moveText.Length && char.IsWhiteSpace(moveText[i]))
                {
                    i++;
                }

                tokens.Add(new PgnToken(start, i - start, false, null));
                tokenStart = i;
                continue;
            }

            if (c == '(')
            {
                FlushCurrent(i);
                tokens.Add(new PgnToken(i, 1, false, null));
                variationDepth++;
                i++;
                tokenStart = i;
                continue;
            }

            if (c == ')')
            {
                FlushCurrent(i);
                tokens.Add(new PgnToken(i, 1, false, null));
                if (variationDepth > 0)
                {
                    variationDepth--;
                }

                i++;
                tokenStart = i;
                continue;
            }

            i++;
        }

        FlushCurrent(moveText.Length);
        return tokens;
    }

    private static bool TryParseMoveToken(ReadOnlySpan<char> token, out string san)
    {
        san = string.Empty;

        if (token.IsEmpty)
        {
            return false;
        }

        var trimmedSpan = token.Trim();
        if (trimmedSpan.IsEmpty)
        {
            return false;
        }

        var trimmed = trimmedSpan.ToString();

        var match = MoveNumberPrefixRegex.Match(trimmed);
        if (match.Success)
        {
            trimmed = match.Groups["rest"].Value.Trim();
            if (trimmed.Length == 0)
            {
                return false;
            }
        }

        if (MoveNumberOnlyRegex.IsMatch(trimmed))
        {
            return false;
        }

        if (trimmed == "..." || trimmed == "..")
        {
            return false;
        }

        if (ResultTokens.Contains(trimmed))
        {
            return false;
        }

        if (NagRegex.IsMatch(trimmed))
        {
            return false;
        }

        if (string.Equals(trimmed, "e.p.", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(trimmed, "ep", StringComparison.OrdinalIgnoreCase))
        {
            return false;
        }

        var sanitized = InlineNagRegex.Replace(trimmed, string.Empty);
        sanitized = SanitizeSan(sanitized);

        if (sanitized.Length == 0)
        {
            return false;
        }

        san = sanitized;
        return true;
    }

    private struct RunningEleganceMetrics
    {
        public int PlyCount;
        public int EvaluatedPlyCount;
        public int ForcingMoveCount;
        public int QuietImprovementCount;
        public int TrendBreakCount;
        public int BlunderCount;
        public int MistakeCount;
        public int DubiousCount;
        public int SoundSacrificeCount;
        public int UnsoundSacrificeCount;
        public int SoundSacrificeCp;
        public int UnsoundSacrificeCp;
        public double SwingAbsSum;
        public int SwingCount;
        public double MoverDeltaSum;
        public double MoverDeltaSquareSum;
        public int MoverDeltaCount;
        public int? PreviousEvalWhiteCp;
        public double? WhiteLastEval;
        public double? WhitePreviousDelta;
        public double? BlackLastEval;
        public double? BlackPreviousDelta;
    }
}

/// <summary>
/// Minimal UCI engine wrapper.
/// </summary>
internal sealed class UciEngine : IDisposable
{
    private static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(10);
    private const int MateCpBase = 100_000;
    private int _abortRequested;

    private static readonly Regex ScoreCpRegex = new(@"\bscore\s+cp\s+(-?\d+)", RegexOptions.Compiled);
    private static readonly Regex ScoreMateRegex = new(@"\bscore\s+mate\s+(-?\d+)", RegexOptions.Compiled);
    private static readonly Regex DepthRegex = new(@"\bdepth\s+(\d+)", RegexOptions.Compiled);

    private readonly Process _process;
    private readonly Channel<string> _stdoutChannel = Channel.CreateUnbounded<string>(
        new UnboundedChannelOptions
        {
            SingleWriter = true,
            SingleReader = false
        });
    private CancellationTokenSource? _stdoutCts;
    private Task? _stdoutReader;

    public UciEngine(string enginePath)
    {
        _process = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = enginePath,
                UseShellExecute = false,
                RedirectStandardInput = true,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            }
        };

        // Drain stderr to avoid blocking if the engine writes warnings or errors.
        _process.ErrorDataReceived += (_, _) => { };
    }

    public bool HasExited
    {
        get
        {
            try
            {
                return _process.HasExited;
            }
            catch (InvalidOperationException)
            {
                return true;
            }
        }
    }

    public async Task StartAsync(CancellationToken cancellationToken = default)
    {
        ThrowIfAborted();

        var started = false;
        try
        {
            if (!_process.Start())
            {
                throw new InvalidOperationException("Failed to start UCI engine process.");
            }

            started = true;
            _process.BeginErrorReadLine();
            StartOutputReader();

            await SendAsync("uci", cancellationToken).ConfigureAwait(false);
            await WaitForTokenAsync("uciok", DefaultTimeout, cancellationToken).ConfigureAwait(false);

            await SendAsync("isready", cancellationToken).ConfigureAwait(false);
            await WaitForTokenAsync("readyok", DefaultTimeout, cancellationToken).ConfigureAwait(false);
        }
        catch
        {
            if (started)
            {
                try
                {
                    if (!_process.HasExited)
                    {
                        _process.Kill(entireProcessTree: true);
                    }
                }
                catch
                {
                }
            }

            throw;
        }
    }

    public async Task NewGameAsync(CancellationToken cancellationToken = default, bool waitForReady = false)
    {
        ThrowIfAborted();
        await SendAsync("ucinewgame", cancellationToken).ConfigureAwait(false);

        if (waitForReady)
        {
            await SendAsync("isready", cancellationToken).ConfigureAwait(false);
            await WaitForTokenAsync("readyok", DefaultTimeout, cancellationToken).ConfigureAwait(false);
        }
    }

    public async Task SetOptionAsync(string name, string value, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            throw new ArgumentException("Option name is required.", nameof(name));
        }

        if (string.IsNullOrWhiteSpace(value))
        {
            return;
        }

        ThrowIfAborted();
        await SendAsync($"setoption name {name} value {value}", cancellationToken).ConfigureAwait(false);
        await SendAsync("isready", cancellationToken).ConfigureAwait(false);
        await WaitForTokenAsync("readyok", DefaultTimeout, cancellationToken).ConfigureAwait(false);
    }

    public async Task<EngineScore> AnalyzeAsync(string fen, int depth, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(fen))
        {
            throw new ArgumentException("FEN is required.", nameof(fen));
        }

        if (depth <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(depth), "Depth must be greater than zero.");
        }

        ThrowIfAborted();
        cancellationToken.ThrowIfCancellationRequested();

        await SendAsync($"position fen {fen}", cancellationToken).ConfigureAwait(false);
        await SendAsync($"go depth {depth}", cancellationToken).ConfigureAwait(false);

        var timeout = GetAnalysisTimeout(depth);
        return await ReadScoreUntilBestMoveAsync(timeout, cancellationToken).ConfigureAwait(false);
    }

    private async Task SendAsync(string command, CancellationToken cancellationToken)
    {
        ThrowIfAborted();
        cancellationToken.ThrowIfCancellationRequested();
        await _process.StandardInput.WriteLineAsync(command).ConfigureAwait(false);
        await _process.StandardInput.FlushAsync().ConfigureAwait(false);
    }

    private void StartOutputReader()
    {
        if (_stdoutReader != null)
        {
            return;
        }

        _stdoutCts = new CancellationTokenSource();
        _stdoutReader = Task.Run(() => ReadStdoutLoopAsync(_stdoutCts.Token));
    }

    private async Task ReadStdoutLoopAsync(CancellationToken cancellationToken)
    {
        try
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var line = await _process.StandardOutput.ReadLineAsync(cancellationToken).ConfigureAwait(false);
                if (line == null)
                {
                    break;
                }

                await _stdoutChannel.Writer.WriteAsync(line, cancellationToken).ConfigureAwait(false);
            }
        }
        catch (OperationCanceledException)
        {
            // Expected during shutdown.
        }
        catch (Exception ex)
        {
            _stdoutChannel.Writer.TryComplete(ex);
            return;
        }

        _stdoutChannel.Writer.TryComplete();
    }

    private async Task<string?> ReadLineWithTimeoutAsync(TimeSpan timeout, CancellationToken cancellationToken)
    {
        if (_stdoutChannel.Reader.Completion.IsCompleted)
        {
            return null;
        }

        using var timeoutCts = new CancellationTokenSource(timeout);
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token);
        try
        {
            return await _stdoutChannel.Reader.ReadAsync(linkedCts.Token).ConfigureAwait(false);
        }
        catch (ChannelClosedException)
        {
            return null;
        }
        catch (OperationCanceledException) when (timeoutCts.IsCancellationRequested && !cancellationToken.IsCancellationRequested)
        {
            throw new TimeoutException("Timed out waiting for engine output.");
        }
    }

    private void ThrowIfAborted()
    {
        if (Volatile.Read(ref _abortRequested) == 1)
        {
            throw new OperationCanceledException("Engine request was aborted.");
        }
    }

    private static TimeSpan GetAnalysisTimeout(int depth)
    {
        // Heuristic timeout scaling with depth; capped to avoid hangs.
        var seconds = Math.Clamp((int)Math.Ceiling(depth * 2.5), 15, 120);
        return TimeSpan.FromSeconds(seconds);
    }

    private async Task<EngineScore> ReadScoreUntilBestMoveAsync(TimeSpan timeout, CancellationToken cancellationToken)
    {
        var deadline = DateTime.UtcNow + timeout;
        var bestDepth = -1;
        var bestScore = EngineScore.FromCentipawns(0);
        var timedOut = false;

        while (true)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var remaining = deadline - DateTime.UtcNow;
            if (remaining <= TimeSpan.Zero)
            {
                timedOut = true;
                break;
            }

            string? line;
            try
            {
                line = await ReadLineWithTimeoutAsync(remaining, cancellationToken).ConfigureAwait(false);
            }
            catch (TimeoutException)
            {
                timedOut = true;
                break;
            }

            if (line == null)
            {
                break;
            }

            if (line.StartsWith("bestmove", StringComparison.OrdinalIgnoreCase))
            {
                return bestScore;
            }

            if (!line.StartsWith("info", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            var depth = TryParseDepth(line);
            var score = TryParseScore(line);

            if (!score.HasValue)
            {
                continue;
            }

            if (depth >= bestDepth)
            {
                bestDepth = depth;
                bestScore = score.Value;
            }
        }

        if (timedOut)
        {
            await StopSearchAndDrainAsync(cancellationToken).ConfigureAwait(false);
        }

        // Return the best score we saw before timing out.
        return bestScore;
    }

    private async Task StopSearchAndDrainAsync(CancellationToken cancellationToken)
    {
        try
        {
            await SendAsync("stop", cancellationToken).ConfigureAwait(false);
        }
        catch
        {
            return;
        }

        try
        {
            await WaitForTokenAsync("bestmove", TimeSpan.FromMilliseconds(500), cancellationToken)
                .ConfigureAwait(false);
        }
        catch (TimeoutException)
        {
        }
        catch (InvalidOperationException)
        {
        }
    }

    private static int TryParseDepth(string line)
    {
        var match = DepthRegex.Match(line);
        return match.Success && int.TryParse(match.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var depth)
            ? depth
            : -1;
    }

    private static EngineScore? TryParseScore(string line)
    {
        var mateMatch = ScoreMateRegex.Match(line);
        if (mateMatch.Success && int.TryParse(mateMatch.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var mateIn))
        {
            var sign = Math.Sign(mateIn);
            var distance = Math.Min(999, Math.Abs(mateIn));
            var cpEquivalent = sign * (MateCpBase - distance * 100);
            return EngineScore.FromMate(mateIn, cpEquivalent);
        }

        var cpMatch = ScoreCpRegex.Match(line);
        if (cpMatch.Success && int.TryParse(cpMatch.Groups[1].Value, NumberStyles.Integer, CultureInfo.InvariantCulture, out var cp))
        {
            return EngineScore.FromCentipawns(cp);
        }

        return null;
    }

    private async Task WaitForTokenAsync(string token, TimeSpan timeout, CancellationToken cancellationToken)
    {
        var deadline = DateTime.UtcNow + timeout;

        while (DateTime.UtcNow < deadline)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var remaining = deadline - DateTime.UtcNow;
            if (remaining <= TimeSpan.Zero)
            {
                break;
            }

            string? line;
            try
            {
                line = await ReadLineWithTimeoutAsync(remaining, cancellationToken).ConfigureAwait(false);
            }
            catch (TimeoutException)
            {
                break;
            }
            if (line == null)
            {
                break;
            }

            if (line.Contains(token, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }
        }

        throw new TimeoutException($"Timed out waiting for engine response: {token}");
    }

    public void RequestAbort()
    {
        if (Interlocked.Exchange(ref _abortRequested, 1) == 1)
        {
            return;
        }

        try
        {
            _stdoutCts?.Cancel();
        }
        catch
        {
        }

        // Best-effort attempt to stop the current search and unblock readers.
        try
        {
            if (!_process.HasExited)
            {
                _process.StandardInput.WriteLine("stop");
                _process.StandardInput.Flush();
            }
        }
        catch
        {
        }

        try
        {
            if (!_process.HasExited)
            {
                _process.Kill(entireProcessTree: true);
            }
        }
        catch
        {
        }
    }

    public void Dispose()
    {
        try
        {
            try
            {
                _stdoutCts?.Cancel();
            }
            catch
            {
            }

            if (!_process.HasExited)
            {
                _process.StandardInput.WriteLine("quit");
                _process.StandardInput.Flush();
                if (!_process.WaitForExit(2000))
                {
                    _process.Kill(entireProcessTree: true);
                }
            }
        }
        catch
        {
        }
        finally
        {
            try
            {
                _stdoutReader?.Wait(500);
            }
            catch
            {
            }

            _stdoutCts?.Dispose();
            _process.Dispose();
        }
    }
}
===== END: PgnTools\Services\ChessAnalyzerService.cs =====

===== BEGIN: PgnTools\Services\EleganceGoldenValidationService.cs =====
using System.Text.Json;

namespace PgnTools.Services;

public sealed record EleganceGoldenCaseResult(
    string Name,
    string InputFilePath,
    double Score,
    bool Passed,
    string Message);

public sealed record EleganceGoldenValidationSummary(
    int Total,
    int Passed,
    IReadOnlyList<EleganceGoldenCaseResult> Cases);

public interface IEleganceGoldenValidationService
{
    Task<EleganceGoldenValidationSummary> ValidateAsync(
        string manifestPath,
        string enginePath,
        int depth,
        IProgress<string>? status = null,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// Runs regression checks for known "golden" games against expected Elegance score ranges.
/// </summary>
public sealed class EleganceGoldenValidationService : IEleganceGoldenValidationService
{
    private readonly IEleganceService _eleganceService;

    public EleganceGoldenValidationService(IEleganceService eleganceService)
    {
        _eleganceService = eleganceService;
    }

    public async Task<EleganceGoldenValidationSummary> ValidateAsync(
        string manifestPath,
        string enginePath,
        int depth,
        IProgress<string>? status = null,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(manifestPath))
        {
            throw new ArgumentException("Manifest path is required.", nameof(manifestPath));
        }

        if (string.IsNullOrWhiteSpace(enginePath))
        {
            throw new ArgumentException("Engine path is required.", nameof(enginePath));
        }

        if (depth <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(depth), "Depth must be greater than zero.");
        }

        var manifestFullPath = Path.GetFullPath(manifestPath);
        if (!File.Exists(manifestFullPath))
        {
            throw new FileNotFoundException("Golden validation manifest not found.", manifestFullPath);
        }

        var manifest = await LoadManifestAsync(manifestFullPath, cancellationToken).ConfigureAwait(false);
        if (manifest.Cases.Count == 0)
        {
            return new EleganceGoldenValidationSummary(0, 0, []);
        }

        var results = new List<EleganceGoldenCaseResult>(manifest.Cases.Count);
        var manifestDirectory = Path.GetDirectoryName(manifestFullPath) ?? Directory.GetCurrentDirectory();

        for (var i = 0; i < manifest.Cases.Count; i++)
        {
            cancellationToken.ThrowIfCancellationRequested();
            var golden = manifest.Cases[i];

            status?.Report($"Validating {i + 1}/{manifest.Cases.Count}: {golden.Name}");

            var inputPath = ResolveInputPath(manifestDirectory, golden.InputFilePath);
            if (!File.Exists(inputPath))
            {
                results.Add(new EleganceGoldenCaseResult(
                    golden.Name,
                    inputPath,
                    0,
                    false,
                    "Input PGN not found."));
                continue;
            }

            var tempOutput = Path.Combine(Path.GetTempPath(), $"pgntools-elegance-golden-{Guid.NewGuid():N}.pgn");

            try
            {
                var result = await _eleganceService.TagEleganceAsync(
                    inputPath,
                    tempOutput,
                    enginePath,
                    depth,
                    progress: null,
                    cancellationToken).ConfigureAwait(false);

                if (result.ProcessedGames == 0)
                {
                    results.Add(new EleganceGoldenCaseResult(
                        golden.Name,
                        inputPath,
                        0,
                        false,
                        "No games were processed."));
                    continue;
                }

                var score = result.AverageScore;
                var passed = (!golden.MinScore.HasValue || score >= golden.MinScore.Value) &&
                             (!golden.MaxScore.HasValue || score <= golden.MaxScore.Value);

                var minText = golden.MinScore.HasValue ? golden.MinScore.Value.ToString("0.##") : "-inf";
                var maxText = golden.MaxScore.HasValue ? golden.MaxScore.Value.ToString("0.##") : "+inf";
                var message = passed
                    ? $"Score {score:0.##} within expected range [{minText}, {maxText}]"
                    : $"Score {score:0.##} outside expected range [{minText}, {maxText}]";

                results.Add(new EleganceGoldenCaseResult(
                    golden.Name,
                    inputPath,
                    score,
                    passed,
                    message));
            }
            finally
            {
                if (File.Exists(tempOutput))
                {
                    try
                    {
                        File.Delete(tempOutput);
                    }
                    catch
                    {
                    }
                }
            }
        }

        var passedCount = results.Count(r => r.Passed);
        return new EleganceGoldenValidationSummary(results.Count, passedCount, results);
    }

    private static async Task<GoldenManifest> LoadManifestAsync(string path, CancellationToken cancellationToken)
    {
        await using var stream = File.OpenRead(path);
        var manifest = await JsonSerializer.DeserializeAsync<GoldenManifest>(stream, cancellationToken: cancellationToken).ConfigureAwait(false);
        return manifest ?? new GoldenManifest();
    }

    private static string ResolveInputPath(string manifestDirectory, string inputPath)
    {
        if (Path.IsPathRooted(inputPath))
        {
            return Path.GetFullPath(inputPath);
        }

        return Path.GetFullPath(Path.Combine(manifestDirectory, inputPath));
    }

    private sealed class GoldenManifest
    {
        public List<GoldenCase> Cases { get; set; } = [];
    }

    private sealed class GoldenCase
    {
        public string Name { get; set; } = "Unnamed Golden";
        public string InputFilePath { get; set; } = string.Empty;
        public double? MinScore { get; set; }
        public double? MaxScore { get; set; }
    }
}
===== END: PgnTools\Services\EleganceGoldenValidationService.cs =====

===== BEGIN: PgnTools\Services\EleganceScoreCalculator.cs =====
using System.Globalization;
using System.Text.Json;

namespace PgnTools.Services;

internal readonly record struct EleganceScore(
    int Score,
    double Soundness,
    double Coherence,
    double Tactical,
    double Quiet,
    double LengthPenalty);

internal readonly record struct EleganceEvaluationMetrics(
    int PlyCount,
    int EvaluatedPlyCount,
    double ForcingMovePercent,
    int QuietImprovementCount,
    int TrendBreakCount,
    int BlunderCount,
    int MistakeCount,
    int DubiousCount,
    double AverageAbsSwingCp,
    double EvalStdDevCp,
    int SoundSacrificeCount,
    int UnsoundSacrificeCount,
    int SoundSacrificeCp,
    int UnsoundSacrificeCp);

internal static class EleganceScoreCalculator
{
    private static readonly NormalizationDistributions Norms = NormalizationDistributions.Load();

    public static EleganceScore Calculate(in EleganceEvaluationMetrics metrics)
    {
        if (metrics.PlyCount <= 0)
        {
            return default;
        }

        var coverage = metrics.PlyCount > 0 ? metrics.EvaluatedPlyCount / (double)metrics.PlyCount : 0d;

        var soundnessRaw = metrics.AverageAbsSwingCp + (metrics.BlunderCount * 25d) + (metrics.MistakeCount * 10d) + (metrics.DubiousCount * 5d);
        var coherenceRaw = metrics.EvalStdDevCp + (metrics.TrendBreakCount * 18d);
        var tacticalRaw = metrics.ForcingMovePercent;
        var quietRaw = metrics.PlyCount > 0 ? metrics.QuietImprovementCount * 100d / metrics.PlyCount : 0d;

        // Sacrifice awareness: reward compensated material losses, penalize unsound ones.
        var soundSacrificeUnits = metrics.SoundSacrificeCp / 100d;
        var unsoundSacrificeUnits = metrics.UnsoundSacrificeCp / 100d;
        soundnessRaw += unsoundSacrificeUnits * 35d;
        quietRaw += (soundSacrificeUnits * 0.75d) + (metrics.SoundSacrificeCount * 0.35d);
        quietRaw -= (unsoundSacrificeUnits * 0.40d) + (metrics.UnsoundSacrificeCount * 0.25d);
        quietRaw = Math.Max(0d, quietRaw);

        var soundness = Norms.Normalize(DistributionType.Soundness, soundnessRaw);
        var coherence = Norms.Normalize(DistributionType.Coherence, coherenceRaw);
        var tactical = Norms.Normalize(DistributionType.TacticalDensity, tacticalRaw);
        var quiet = Norms.Normalize(DistributionType.QuietBrilliancy, quietRaw);
        var lengthPenalty = ComputeLengthPenalty(metrics.PlyCount);

        if (coverage < 0.8d)
        {
            var scale = Math.Clamp((coverage - 0.2d) / 0.6d, 0d, 1d);
            soundness *= scale;
            coherence *= scale;
            quiet *= scale;
        }

        var rawScore =
            (0.25d * soundness) +
            (0.20d * coherence) +
            (0.20d * tactical) +
            (0.30d * quiet) -
            (0.05d * lengthPenalty);

        var score = (int)Math.Round(Math.Clamp(rawScore, 0d, 100d), MidpointRounding.AwayFromZero);

        return new EleganceScore(score, soundness, coherence, tactical, quiet, lengthPenalty);
    }

    public static string FormatDetails(in EleganceScore elegance)
    {
        return FormattableString.Invariant(
            $"S={Math.Round(elegance.Soundness, MidpointRounding.AwayFromZero):0};C={Math.Round(elegance.Coherence, MidpointRounding.AwayFromZero):0};T={Math.Round(elegance.Tactical, MidpointRounding.AwayFromZero):0};Q={Math.Round(elegance.Quiet, MidpointRounding.AwayFromZero):0};L={Math.Round(elegance.LengthPenalty, MidpointRounding.AwayFromZero):0}");
    }

    private static double ComputeLengthPenalty(int plyCount)
    {
        const int threshold = 160;
        if (plyCount <= threshold)
        {
            return 0;
        }

        var distance = plyCount - threshold;
        return 100d * (1d - 1d / (1d + Math.Exp(-distance / 30d)));
    }

    private enum DistributionType
    {
        Soundness,
        Coherence,
        TacticalDensity,
        QuietBrilliancy
    }

    private sealed class NormalizationDistributions
    {
        private readonly Dictionary<DistributionType, DistributionBand> _bands;

        private NormalizationDistributions(Dictionary<DistributionType, DistributionBand> bands)
        {
            _bands = bands;
        }

        public static NormalizationDistributions Load()
        {
            var bands = CreateDefaultBands();
            var configPath = ResolveConfigPath();
            if (string.IsNullOrWhiteSpace(configPath))
            {
                return new NormalizationDistributions(bands);
            }

            try
            {
                using var stream = File.OpenRead(configPath);
                var config = JsonSerializer.Deserialize<NormalizationConfig>(stream);
                if (config?.Distributions == null)
                {
                    return new NormalizationDistributions(bands);
                }

                foreach (var entry in config.Distributions)
                {
                    if (!TryMapDistribution(entry.Key, out var type))
                    {
                        continue;
                    }

                    var value = entry.Value;
                    if (value == null || !value.P10.HasValue || !value.P90.HasValue || !value.HigherIsBetter.HasValue)
                    {
                        continue;
                    }

                    bands[type] = new DistributionBand(value.P10.Value, value.P90.Value, value.HigherIsBetter.Value);
                }
            }
            catch
            {
            }

            return new NormalizationDistributions(bands);
        }

        public double Normalize(DistributionType type, double rawValue)
        {
            if (!_bands.TryGetValue(type, out var band))
            {
                return 50;
            }

            return band.Normalize(rawValue);
        }

        private static Dictionary<DistributionType, DistributionBand> CreateDefaultBands()
        {
            return new Dictionary<DistributionType, DistributionBand>
            {
                { DistributionType.Soundness, new DistributionBand(45d, 280d, HigherIsBetter: false) },
                { DistributionType.Coherence, new DistributionBand(35d, 240d, HigherIsBetter: false) },
                { DistributionType.TacticalDensity, new DistributionBand(22d, 56d, HigherIsBetter: true) },
                { DistributionType.QuietBrilliancy, new DistributionBand(0.4d, 6.5d, HigherIsBetter: true) }
            };
        }

        private static string? ResolveConfigPath()
        {
            var primary = Path.Combine(AppContext.BaseDirectory, "Assets", "elegance-distributions.json");
            if (File.Exists(primary))
            {
                return primary;
            }

            var secondary = Path.Combine(AppContext.BaseDirectory, "elegance-distributions.json");
            return File.Exists(secondary) ? secondary : null;
        }

        private static bool TryMapDistribution(string key, out DistributionType type)
        {
            type = default;
            if (string.IsNullOrWhiteSpace(key))
            {
                return false;
            }

            return key.Trim().ToLowerInvariant() switch
            {
                "soundness" => Assign(DistributionType.Soundness, out type),
                "coherence" => Assign(DistributionType.Coherence, out type),
                "tacticaldensity" => Assign(DistributionType.TacticalDensity, out type),
                "quietbrilliancy" => Assign(DistributionType.QuietBrilliancy, out type),
                _ => false
            };
        }

        private static bool Assign(DistributionType mapped, out DistributionType type)
        {
            type = mapped;
            return true;
        }
    }

    private readonly record struct DistributionBand(double P10, double P90, bool HigherIsBetter)
    {
        public double Normalize(double rawValue)
        {
            if (P90 <= P10)
            {
                return 50;
            }

            var t = (rawValue - P10) / (P90 - P10);
            if (!HigherIsBetter)
            {
                t = 1d - t;
            }

            return Math.Clamp(t, 0d, 1d) * 100d;
        }
    }

    private sealed class NormalizationConfig
    {
        public Dictionary<string, DistributionConfigEntry>? Distributions { get; set; }
    }

    private sealed class DistributionConfigEntry
    {
        public double? P10 { get; set; }
        public double? P90 { get; set; }
        public bool? HigherIsBetter { get; set; }
    }
}
===== END: PgnTools\Services\EleganceScoreCalculator.cs =====

===== BEGIN: PgnTools\Services\EleganceService.cs =====
using System.Globalization;
using System.Text;
using System.Text.Json;
using PgnTools.Helpers;

namespace PgnTools.Services;

public sealed record EleganceTaggerResult(
    long ProcessedGames,
    double AverageScore,
    double AverageSoundness,
    double AverageCoherence,
    double AverageTactical,
    double AverageQuiet);

public interface IEleganceService
{
    Task<EleganceTaggerResult> TagEleganceAsync(
        string inputFilePath,
        string outputFilePath,
        string enginePath,
        int depth,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default);
}

/// <summary>
/// Tags each game with engine-backed Elegance component scores (0..100).
/// </summary>
public sealed class EleganceService : IEleganceService
{
    private const int BufferSize = 65536;
    private const int MateCpBase = 100000;
    private const int AnalyzerProgressWeight = 70;
    private const int ProgressGameInterval = 200;
    private static readonly TimeSpan ProgressTimeInterval = TimeSpan.FromMilliseconds(100);

    private static readonly NormalizationDistributions Norms = NormalizationDistributions.Load();

    private readonly IChessAnalyzerService _analyzer;
    private readonly PgnReader _pgnReader;
    private readonly PgnWriter _pgnWriter;

    public EleganceService(
        IChessAnalyzerService analyzer,
        PgnReader pgnReader,
        PgnWriter pgnWriter)
    {
        _analyzer = analyzer;
        _pgnReader = pgnReader;
        _pgnWriter = pgnWriter;
    }

    public async Task<EleganceTaggerResult> TagEleganceAsync(
        string inputFilePath,
        string outputFilePath,
        string enginePath,
        int depth,
        IProgress<double>? progress = null,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(inputFilePath))
        {
            throw new ArgumentException("Input file path is required.", nameof(inputFilePath));
        }

        if (string.IsNullOrWhiteSpace(outputFilePath))
        {
            throw new ArgumentException("Output file path is required.", nameof(outputFilePath));
        }

        if (string.IsNullOrWhiteSpace(enginePath))
        {
            throw new ArgumentException("Engine path is required.", nameof(enginePath));
        }

        if (depth <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(depth), "Depth must be greater than zero.");
        }

        var inputFullPath = Path.GetFullPath(inputFilePath);
        var outputFullPath = Path.GetFullPath(outputFilePath);
        var engineFullPath = Path.GetFullPath(enginePath);
        var tempAnalyzedPath = Path.Combine(Path.GetTempPath(), $"pgntools-elegance-analyzed-{Guid.NewGuid():N}.pgn");
        var tempOutputPath = FileReplacementHelper.CreateTempFilePath(outputFullPath);

        if (!File.Exists(inputFullPath))
        {
            throw new FileNotFoundException("Input PGN file not found.", inputFullPath);
        }

        if (!File.Exists(engineFullPath))
        {
            throw new FileNotFoundException("UCI engine not found.", engineFullPath);
        }

        if (string.Equals(inputFullPath, outputFullPath, StringComparison.OrdinalIgnoreCase))
        {
            throw new InvalidOperationException("Input and output files must be different.");
        }

        var outputDirectory = Path.GetDirectoryName(outputFullPath);
        if (!string.IsNullOrWhiteSpace(outputDirectory))
        {
            Directory.CreateDirectory(outputDirectory);
        }

        var processedGames = 0L;
        var cumulativeScore = 0d;
        var cumulativeSoundness = 0d;
        var cumulativeCoherence = 0d;
        var cumulativeTactical = 0d;
        var cumulativeQuiet = 0d;
        var lastProgressReport = DateTime.MinValue;

        try
        {
            var analyzerProgress = new Progress<AnalyzerProgress>(p =>
            {
                var scaled = Math.Clamp(p.Percent, 0, 100) * AnalyzerProgressWeight / 100d;
                progress?.Report(scaled);
            });

            await _analyzer.AnalyzePgnAsync(
                inputFullPath,
                tempAnalyzedPath,
                engineFullPath,
                depth,
                tablebasePath: null,
                analyzerProgress,
                cancellationToken).ConfigureAwait(false);

            if (!File.Exists(tempAnalyzedPath))
            {
                progress?.Report(100);
                return new EleganceTaggerResult(0, 0, 0, 0, 0, 0);
            }

            await using var analyzedStream = new FileStream(
                tempAnalyzedPath,
                FileMode.Open,
                FileAccess.Read,
                FileShare.Read,
                BufferSize,
                FileOptions.SequentialScan | FileOptions.Asynchronous);

            await using (var outputStream = new FileStream(
                tempOutputPath,
                FileMode.Create,
                FileAccess.Write,
                FileShare.None,
                BufferSize,
                FileOptions.SequentialScan | FileOptions.Asynchronous))
            using (var writer = new StreamWriter(outputStream, new UTF8Encoding(false), BufferSize, leaveOpen: true))
            {
                var firstOutput = true;

                await foreach (var game in _pgnReader.ReadGamesAsync(analyzedStream, cancellationToken).ConfigureAwait(false))
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    processedGames++;

                    var startingSideIsWhite = IsWhiteToMove(game.Headers);
                    var parsed = ParseAnalyzedGame(game.MoveText, startingSideIsWhite);
                    var elegance = CalculateElegance(parsed);

                    cumulativeScore += elegance.Score;
                    cumulativeSoundness += elegance.Soundness;
                    cumulativeCoherence += elegance.Coherence;
                    cumulativeTactical += elegance.Tactical;
                    cumulativeQuiet += elegance.Quiet;

                    game.Headers["Elegance"] = elegance.Score.ToString(CultureInfo.InvariantCulture);
                    game.Headers["EleganceDetails"] = FormatDetails(elegance);

                    if (!firstOutput)
                    {
                        await writer.WriteLineAsync().ConfigureAwait(false);
                    }

                    await _pgnWriter.WriteGameAsync(writer, game, cancellationToken).ConfigureAwait(false);
                    firstOutput = false;

                    if (ShouldReportProgress(processedGames, ref lastProgressReport))
                    {
                        var scoringPercent = GetProgressPercent(analyzedStream);
                        var totalPercent = AnalyzerProgressWeight + (100 - AnalyzerProgressWeight) * (scoringPercent / 100d);
                        progress?.Report(Math.Clamp(totalPercent, 0, 100));
                    }
                }

                await writer.FlushAsync().ConfigureAwait(false);
            }

            if (processedGames == 0)
            {
                if (File.Exists(tempOutputPath))
                {
                    File.Delete(tempOutputPath);
                }

                progress?.Report(100);
                return new EleganceTaggerResult(0, 0, 0, 0, 0, 0);
            }

            FileReplacementHelper.ReplaceFile(tempOutputPath, outputFullPath);
            progress?.Report(100);

            return new EleganceTaggerResult(
                processedGames,
                cumulativeScore / processedGames,
                cumulativeSoundness / processedGames,
                cumulativeCoherence / processedGames,
                cumulativeTactical / processedGames,
                cumulativeQuiet / processedGames);
        }
        catch
        {
            if (File.Exists(tempOutputPath))
            {
                try
                {
                    File.Delete(tempOutputPath);
                }
                catch
                {
                }
            }

            throw;
        }
        finally
        {
            if (File.Exists(tempAnalyzedPath))
            {
                try
                {
                    File.Delete(tempAnalyzedPath);
                }
                catch
                {
                }
            }
        }
    }

    private static string FormatDetails(in EleganceBreakdown elegance)
    {
        return FormattableString.Invariant(
            $"S={Math.Round(elegance.Soundness, MidpointRounding.AwayFromZero):0};C={Math.Round(elegance.Coherence, MidpointRounding.AwayFromZero):0};T={Math.Round(elegance.Tactical, MidpointRounding.AwayFromZero):0};Q={Math.Round(elegance.Quiet, MidpointRounding.AwayFromZero):0};L={Math.Round(elegance.LengthPenalty, MidpointRounding.AwayFromZero):0}");
    }

    private static EleganceBreakdown CalculateElegance(in ParsedGameMetrics metrics)
    {
        if (metrics.PlyCount <= 0)
        {
            return default;
        }

        var coverage = metrics.PlyCount > 0 ? metrics.EvaluatedPlyCount / (double)metrics.PlyCount : 0d;

        var soundnessRaw = metrics.AverageAbsSwingCp + (metrics.BlunderCount * 25d) + (metrics.MistakeCount * 10d) + (metrics.DubiousCount * 5d);
        var coherenceRaw = metrics.EvalStdDevCp + (metrics.TrendBreakCount * 18d);
        var tacticalRaw = metrics.ForcingMovePercent;
        var quietRaw = metrics.PlyCount > 0 ? metrics.QuietImprovementCount * 100d / metrics.PlyCount : 0d;

        var soundness = Norms.Normalize(DistributionType.Soundness, soundnessRaw);
        var coherence = Norms.Normalize(DistributionType.Coherence, coherenceRaw);
        var tactical = Norms.Normalize(DistributionType.TacticalDensity, tacticalRaw);
        var quiet = Norms.Normalize(DistributionType.QuietBrilliancy, quietRaw);
        var lengthPenalty = ComputeLengthPenalty(metrics.PlyCount);

        if (coverage < 0.8d)
        {
            // Keep scores meaningful when analysis coverage is partial.
            var scale = Math.Clamp((coverage - 0.2d) / 0.6d, 0d, 1d);
            soundness *= scale;
            coherence *= scale;
            quiet *= scale;
        }

        var rawScore =
            (0.25d * soundness) +
            (0.20d * coherence) +
            (0.20d * tactical) +
            (0.30d * quiet) -
            (0.05d * lengthPenalty);

        var score = (int)Math.Round(Math.Clamp(rawScore, 0d, 100d), MidpointRounding.AwayFromZero);

        return new EleganceBreakdown(
            score,
            soundness,
            coherence,
            tactical,
            quiet,
            lengthPenalty);
    }

    private static double ComputeLengthPenalty(int plyCount)
    {
        const int threshold = 160; // 80 full moves
        if (plyCount <= threshold)
        {
            return 0;
        }

        var distance = plyCount - threshold;
        return 100d * (1d - 1d / (1d + Math.Exp(-distance / 30d)));
    }

    private static ParsedGameMetrics ParseAnalyzedGame(string moveText, bool whiteToMove)
    {
        if (string.IsNullOrWhiteSpace(moveText))
        {
            return default;
        }

        var plies = new List<PlyData>(256);
        var token = new StringBuilder(16);
        var commentBuffer = new StringBuilder(32);
        var inBraceComment = false;
        var inLineComment = false;
        var variationDepth = 0;
        var sideToMoveIsWhite = whiteToMove;

        void FlushToken()
        {
            if (token.Length == 0)
            {
                return;
            }

            var raw = token.ToString();
            token.Clear();
            ProcessToken(raw, ref sideToMoveIsWhite, plies);
        }

        for (var i = 0; i < moveText.Length; i++)
        {
            var c = moveText[i];

            if (inLineComment)
            {
                if (c is '\n' or '\r')
                {
                    inLineComment = false;
                }

                continue;
            }

            if (inBraceComment)
            {
                if (c == '}')
                {
                    inBraceComment = false;
                    if (variationDepth == 0 && plies.Count > 0)
                    {
                        ApplyEvalComment(commentBuffer.ToString(), plies);
                    }

                    commentBuffer.Clear();
                }
                else
                {
                    commentBuffer.Append(c);
                }

                continue;
            }

            if (c == '{')
            {
                FlushToken();
                inBraceComment = true;
                commentBuffer.Clear();
                continue;
            }

            if (c == ';')
            {
                FlushToken();
                inLineComment = true;
                continue;
            }

            if (c == '(')
            {
                FlushToken();
                variationDepth++;
                continue;
            }

            if (c == ')')
            {
                FlushToken();
                if (variationDepth > 0)
                {
                    variationDepth--;
                }

                continue;
            }

            if (variationDepth > 0)
            {
                continue;
            }

            if (char.IsWhiteSpace(c))
            {
                FlushToken();
                continue;
            }

            token.Append(c);
        }

        FlushToken();
        return SummarizePlies(plies);
    }

    private static void ProcessToken(string rawToken, ref bool sideToMoveIsWhite, List<PlyData> plies)
    {
        var token = rawToken.Trim();
        if (token.Length == 0)
        {
            return;
        }

        if (TryParseNagToken(token, out var standaloneNag))
        {
            ApplyNagToLastPly(plies, standaloneNag);
            return;
        }

        if (token.All(c => c == '.'))
        {
            return;
        }

        if (TryStripMoveNumberPrefix(token, out var stripped))
        {
            token = stripped;
        }

        token = token.TrimStart('.');
        if (token.Length == 0)
        {
            return;
        }

        if (IsResultToken(token))
        {
            return;
        }

        var blunderSignals = 0;
        var mistakeSignals = 0;
        var dubiousSignals = 0;
        token = RemoveInlineNags(token, ref blunderSignals, ref mistakeSignals, ref dubiousSignals);

        if (token.Length == 0)
        {
            return;
        }

        var hasDoubleQuestion = token.Contains("??", StringComparison.Ordinal);
        var hasDubious = !hasDoubleQuestion && token.Contains("?!", StringComparison.Ordinal);
        var hasSingleQuestion = !hasDoubleQuestion && !hasDubious && token.IndexOf('?') >= 0;

        if (hasDoubleQuestion)
        {
            blunderSignals++;
        }
        else if (hasDubious)
        {
            dubiousSignals++;
        }
        else if (hasSingleQuestion)
        {
            mistakeSignals++;
        }

        var hasCapture = token.IndexOf('x') >= 0;
        var hasCheck = token.IndexOf('+') >= 0;
        var hasMate = token.IndexOf('#') >= 0;
        var hasPromotion = token.IndexOf('=') >= 0;

        var moveToken = token.TrimEnd('!', '?', '+', '#');
        if (moveToken.Length == 0)
        {
            return;
        }

        moveToken = NormalizeCastling(moveToken);
        if (IsResultToken(moveToken))
        {
            return;
        }

        if (moveToken.Equals("e.p.", StringComparison.OrdinalIgnoreCase) ||
            moveToken.Equals("ep", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        var isCastling = moveToken.StartsWith("O-O", StringComparison.Ordinal);
        var first = moveToken[0];
        var isPieceMove = isCastling || first is 'K' or 'Q' or 'R' or 'B' or 'N';
        var isPawnMove = first is >= 'a' and <= 'h';

        if (!isPieceMove && !isPawnMove)
        {
            return;
        }

        var ply = new PlyData
        {
            IsWhiteMove = sideToMoveIsWhite,
            IsCapture = hasCapture,
            IsCheck = hasCheck,
            IsMate = hasMate,
            IsPromotion = hasPromotion,
            IsQuiet = !hasCapture && !hasCheck && !hasMate && !hasPromotion,
            BlunderSignals = blunderSignals,
            MistakeSignals = mistakeSignals,
            DubiousSignals = dubiousSignals
        };

        plies.Add(ply);
        sideToMoveIsWhite = !sideToMoveIsWhite;
    }

    private static void ApplyNagToLastPly(List<PlyData> plies, int nag)
    {
        if (plies.Count == 0)
        {
            return;
        }

        var lastIndex = plies.Count - 1;
        var last = plies[lastIndex];
        ApplyNag(ref last, nag);
        plies[lastIndex] = last;
    }

    private static void ApplyNag(ref PlyData ply, int nag)
    {
        switch (nag)
        {
            case 2:
                ply.MistakeSignals++;
                break;
            case 4:
                ply.BlunderSignals++;
                break;
            case 6:
                ply.DubiousSignals++;
                break;
        }
    }

    private static void ApplyEvalComment(string commentText, List<PlyData> plies)
    {
        if (!TryParseEvalComment(commentText, out var evalAfterWhiteCp))
        {
            return;
        }

        var lastIndex = plies.Count - 1;
        if (lastIndex < 0)
        {
            return;
        }

        var ply = plies[lastIndex];
        ply.HasEval = true;
        ply.EvalAfterWhiteCp = evalAfterWhiteCp;
        plies[lastIndex] = ply;
    }

    private static ParsedGameMetrics SummarizePlies(List<PlyData> plies)
    {
        if (plies.Count == 0)
        {
            return default;
        }

        var forcingCount = 0;
        var evaluatedCount = 0;
        var quietImprovementCount = 0;
        var trendBreakCount = 0;

        var annotationBlunders = 0;
        var annotationMistakes = 0;
        var annotationDubious = 0;
        var evalBlunders = 0;
        var evalMistakes = 0;
        var evalDubious = 0;

        var hasPreviousEval = false;
        var previousEvalWhite = 0d;
        var swingAbsSum = 0d;
        var swingCount = 0;

        var moverDeltaSum = 0d;
        var moverDeltaSquareSum = 0d;
        var moverDeltaCount = 0;

        double? whiteLastEval = null;
        double? blackLastEval = null;
        double? whitePreviousDelta = null;
        double? blackPreviousDelta = null;

        foreach (var ply in plies)
        {
            if (ply.IsCapture || ply.IsCheck || ply.IsMate || ply.IsPromotion)
            {
                forcingCount++;
            }

            annotationBlunders += ply.BlunderSignals;
            annotationMistakes += ply.MistakeSignals;
            annotationDubious += ply.DubiousSignals;

            if (!ply.HasEval)
            {
                continue;
            }

            evaluatedCount++;

            var evalWhite = (double)ply.EvalAfterWhiteCp;

            if (hasPreviousEval)
            {
                var deltaWhite = evalWhite - previousEvalWhite;
                var moverDelta = ply.IsWhiteMove ? deltaWhite : -deltaWhite;

                swingAbsSum += Math.Abs(deltaWhite);
                swingCount++;

                moverDeltaSum += moverDelta;
                moverDeltaSquareSum += moverDelta * moverDelta;
                moverDeltaCount++;

                if (moverDelta <= -300)
                {
                    evalBlunders++;
                }
                else if (moverDelta <= -150)
                {
                    evalMistakes++;
                }
                else if (moverDelta <= -60)
                {
                    evalDubious++;
                }

                if (ply.IsQuiet && moverDelta >= 150)
                {
                    quietImprovementCount++;
                }
            }

            previousEvalWhite = evalWhite;
            hasPreviousEval = true;

            if (ply.IsWhiteMove)
            {
                UpdateTrendMetrics(evalWhite, ref whiteLastEval, ref whitePreviousDelta, ref trendBreakCount);
            }
            else
            {
                UpdateTrendMetrics(-evalWhite, ref blackLastEval, ref blackPreviousDelta, ref trendBreakCount);
            }
        }

        var averageAbsSwing = swingCount > 0 ? swingAbsSum / swingCount : 350d;
        var evalStdDev = 220d;
        if (moverDeltaCount > 0)
        {
            var mean = moverDeltaSum / moverDeltaCount;
            var variance = (moverDeltaSquareSum / moverDeltaCount) - (mean * mean);
            evalStdDev = Math.Sqrt(Math.Max(0d, variance));
        }

        var forcingPercent = plies.Count > 0 ? forcingCount * 100d / plies.Count : 0d;

        return new ParsedGameMetrics(
            plies.Count,
            evaluatedCount,
            forcingPercent,
            quietImprovementCount,
            trendBreakCount,
            Math.Max(annotationBlunders, evalBlunders),
            Math.Max(annotationMistakes, evalMistakes),
            Math.Max(annotationDubious, evalDubious),
            averageAbsSwing,
            evalStdDev);
    }

    private static void UpdateTrendMetrics(
        double evalForSide,
        ref double? lastEval,
        ref double? previousDelta,
        ref int trendBreakCount)
    {
        if (!lastEval.HasValue)
        {
            lastEval = evalForSide;
            return;
        }

        var delta1 = evalForSide - lastEval.Value;

        if (previousDelta.HasValue)
        {
            var previousSign = Math.Sign(previousDelta.Value);
            var currentSign = Math.Sign(delta1);
            var delta2 = delta1 - previousDelta.Value;

            if (previousSign != 0 &&
                currentSign != 0 &&
                previousSign != currentSign &&
                Math.Abs(delta2) >= 50d)
            {
                trendBreakCount++;
            }
        }

        previousDelta = delta1;
        lastEval = evalForSide;
    }

    private static bool IsWhiteToMove(IReadOnlyDictionary<string, string> headers)
    {
        if (!headers.TryGetHeaderValue("FEN", out var fen) || string.IsNullOrWhiteSpace(fen))
        {
            return true;
        }

        var parts = fen.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length < 2)
        {
            return true;
        }

        return !parts[1].Equals("b", StringComparison.OrdinalIgnoreCase);
    }

    private static bool TryParseEvalComment(string commentText, out int evalCp)
    {
        evalCp = 0;

        if (string.IsNullOrWhiteSpace(commentText))
        {
            return false;
        }

        var markerIndex = commentText.IndexOf("eval:", StringComparison.OrdinalIgnoreCase);
        if (markerIndex < 0)
        {
            return false;
        }

        var valuePart = commentText[(markerIndex + 5)..].Trim();
        if (valuePart.Length == 0)
        {
            return false;
        }

        var stopIndex = 0;
        while (stopIndex < valuePart.Length && !char.IsWhiteSpace(valuePart[stopIndex]))
        {
            stopIndex++;
        }

        if (stopIndex <= 0)
        {
            return false;
        }

        var evalToken = valuePart[..stopIndex];
        return TryParseEvalToken(evalToken, out evalCp);
    }

    private static bool TryParseEvalToken(string token, out int evalCp)
    {
        evalCp = 0;

        if (string.IsNullOrWhiteSpace(token))
        {
            return false;
        }

        if (token[0] == '#')
        {
            var matePart = token[1..];
            if (!int.TryParse(matePart, NumberStyles.Integer, CultureInfo.InvariantCulture, out var mateIn))
            {
                return false;
            }

            if (mateIn == 0)
            {
                evalCp = 0;
                return true;
            }

            var sign = Math.Sign(mateIn);
            var distance = Math.Min(999, Math.Abs(mateIn));
            evalCp = sign * (MateCpBase - distance * 100);
            return true;
        }

        if (!double.TryParse(token, NumberStyles.Float, CultureInfo.InvariantCulture, out var pawnValue))
        {
            return false;
        }

        var cp = pawnValue * 100d;
        if (cp > MateCpBase)
        {
            cp = MateCpBase;
        }
        else if (cp < -MateCpBase)
        {
            cp = -MateCpBase;
        }

        evalCp = (int)Math.Round(cp, MidpointRounding.AwayFromZero);
        return true;
    }

    private static bool TryParseNagToken(string token, out int nag)
    {
        nag = 0;
        if (token.Length < 2 || token[0] != '$')
        {
            return false;
        }

        for (var i = 1; i < token.Length; i++)
        {
            if (!char.IsDigit(token[i]))
            {
                return false;
            }
        }

        return int.TryParse(token[1..], NumberStyles.None, CultureInfo.InvariantCulture, out nag);
    }

    private static string RemoveInlineNags(string token, ref int blunderSignals, ref int mistakeSignals, ref int dubiousSignals)
    {
        var firstNag = token.IndexOf('$');
        if (firstNag < 0)
        {
            return token;
        }

        var builder = new StringBuilder(token.Length);
        var index = 0;

        while (index < token.Length)
        {
            var c = token[index];
            if (c != '$')
            {
                builder.Append(c);
                index++;
                continue;
            }

            var digitsStart = index + 1;
            var digitsEnd = digitsStart;
            while (digitsEnd < token.Length && char.IsDigit(token[digitsEnd]))
            {
                digitsEnd++;
            }

            if (digitsEnd == digitsStart)
            {
                builder.Append(c);
                index++;
                continue;
            }

            if (int.TryParse(token[digitsStart..digitsEnd], NumberStyles.None, CultureInfo.InvariantCulture, out var nag))
            {
                switch (nag)
                {
                    case 2:
                        mistakeSignals++;
                        break;
                    case 4:
                        blunderSignals++;
                        break;
                    case 6:
                        dubiousSignals++;
                        break;
                }
            }

            index = digitsEnd;
        }

        return builder.ToString();
    }

    private static bool TryStripMoveNumberPrefix(string token, out string stripped)
    {
        stripped = token;
        var firstDot = token.IndexOf('.');
        if (firstDot < 0)
        {
            return false;
        }

        var prefix = token[..firstDot];
        if (prefix.Length == 0 || !prefix.All(char.IsDigit))
        {
            return false;
        }

        var lastDot = token.LastIndexOf('.');
        if (lastDot >= token.Length - 1)
        {
            stripped = string.Empty;
            return true;
        }

        stripped = token[(lastDot + 1)..];
        return true;
    }

    private static bool IsResultToken(string token)
    {
        return token is "1-0" or "0-1" or "1/2-1/2" or "*";
    }

    private static string NormalizeCastling(string token)
    {
        if (token.Equals("0-0", StringComparison.OrdinalIgnoreCase) ||
            token.Equals("o-o", StringComparison.OrdinalIgnoreCase))
        {
            return "O-O";
        }

        if (token.Equals("0-0-0", StringComparison.OrdinalIgnoreCase) ||
            token.Equals("o-o-o", StringComparison.OrdinalIgnoreCase))
        {
            return "O-O-O";
        }

        return token;
    }

    private static double GetProgressPercent(Stream stream)
    {
        if (!stream.CanSeek || stream.Length == 0)
        {
            return 0;
        }

        var percent = stream.Position / (double)stream.Length * 100;
        if (percent < 0)
        {
            return 0;
        }

        return percent > 100 ? 100 : percent;
    }

    private static bool ShouldReportProgress(long games, ref DateTime lastReportUtc)
    {
        if (games <= 0)
        {
            return false;
        }

        if (games != 1 && games % ProgressGameInterval != 0)
        {
            return false;
        }

        var now = DateTime.UtcNow;
        if (now - lastReportUtc < ProgressTimeInterval)
        {
            return false;
        }

        lastReportUtc = now;
        return true;
    }

    private readonly record struct EleganceBreakdown(
        int Score,
        double Soundness,
        double Coherence,
        double Tactical,
        double Quiet,
        double LengthPenalty);

    private readonly record struct ParsedGameMetrics(
        int PlyCount,
        int EvaluatedPlyCount,
        double ForcingMovePercent,
        int QuietImprovementCount,
        int TrendBreakCount,
        int BlunderCount,
        int MistakeCount,
        int DubiousCount,
        double AverageAbsSwingCp,
        double EvalStdDevCp);

    private struct PlyData
    {
        public bool IsWhiteMove;
        public bool HasEval;
        public int EvalAfterWhiteCp;
        public bool IsCapture;
        public bool IsCheck;
        public bool IsMate;
        public bool IsPromotion;
        public bool IsQuiet;
        public int BlunderSignals;
        public int MistakeSignals;
        public int DubiousSignals;
    }

    private enum DistributionType
    {
        Soundness,
        Coherence,
        TacticalDensity,
        QuietBrilliancy
    }

    private sealed class NormalizationDistributions
    {
        private readonly Dictionary<DistributionType, DistributionBand> _bands;

        private NormalizationDistributions(Dictionary<DistributionType, DistributionBand> bands)
        {
            _bands = bands;
        }

        public static NormalizationDistributions Load()
        {
            var bands = CreateDefaultBands();
            var configPath = ResolveConfigPath();
            if (string.IsNullOrWhiteSpace(configPath))
            {
                return new NormalizationDistributions(bands);
            }

            try
            {
                using var stream = File.OpenRead(configPath);
                var config = JsonSerializer.Deserialize<NormalizationConfig>(stream);
                if (config?.Distributions == null)
                {
                    return new NormalizationDistributions(bands);
                }

                foreach (var entry in config.Distributions)
                {
                    if (!TryMapDistribution(entry.Key, out var type))
                    {
                        continue;
                    }

                    var value = entry.Value;
                    if (value == null || !value.P10.HasValue || !value.P90.HasValue || !value.HigherIsBetter.HasValue)
                    {
                        continue;
                    }

                    bands[type] = new DistributionBand(value.P10.Value, value.P90.Value, value.HigherIsBetter.Value);
                }
            }
            catch
            {
                // Keep defaults if config is missing or malformed.
            }

            return new NormalizationDistributions(bands);
        }

        public double Normalize(DistributionType type, double rawValue)
        {
            if (!_bands.TryGetValue(type, out var band))
            {
                return 50;
            }

            return band.Normalize(rawValue);
        }

        private static Dictionary<DistributionType, DistributionBand> CreateDefaultBands()
        {
            return new Dictionary<DistributionType, DistributionBand>
            {
                // Lower raw values are better for Soundness/Coherence.
                { DistributionType.Soundness, new DistributionBand(45d, 280d, HigherIsBetter: false) },
                { DistributionType.Coherence, new DistributionBand(35d, 240d, HigherIsBetter: false) },
                // Higher is better for Tactical/Quiet components.
                { DistributionType.TacticalDensity, new DistributionBand(22d, 56d, HigherIsBetter: true) },
                { DistributionType.QuietBrilliancy, new DistributionBand(0.4d, 6.5d, HigherIsBetter: true) }
            };
        }

        private static string? ResolveConfigPath()
        {
            var primary = Path.Combine(AppContext.BaseDirectory, "Assets", "elegance-distributions.json");
            if (File.Exists(primary))
            {
                return primary;
            }

            var secondary = Path.Combine(AppContext.BaseDirectory, "elegance-distributions.json");
            return File.Exists(secondary) ? secondary : null;
        }

        private static bool TryMapDistribution(string key, out DistributionType type)
        {
            type = default;

            if (string.IsNullOrWhiteSpace(key))
            {
                return false;
            }

            return key.Trim().ToLowerInvariant() switch
            {
                "soundness" => Assign(DistributionType.Soundness, out type),
                "coherence" => Assign(DistributionType.Coherence, out type),
                "tacticaldensity" => Assign(DistributionType.TacticalDensity, out type),
                "quietbrilliancy" => Assign(DistributionType.QuietBrilliancy, out type),
                _ => false
            };
        }

        private static bool Assign(DistributionType mapped, out DistributionType type)
        {
            type = mapped;
            return true;
        }
    }

    private readonly record struct DistributionBand(double P10, double P90, bool HigherIsBetter)
    {
        public double Normalize(double rawValue)
        {
            if (P90 <= P10)
            {
                return 50;
            }

            var t = (rawValue - P10) / (P90 - P10);
            if (!HigherIsBetter)
            {
                t = 1d - t;
            }

            return Math.Clamp(t, 0d, 1d) * 100d;
        }
    }

    private sealed class NormalizationConfig
    {
        public Dictionary<string, DistributionConfigEntry>? Distributions { get; set; }
    }

    private sealed class DistributionConfigEntry
    {
        public double? P10 { get; set; }
        public double? P90 { get; set; }
        public bool? HigherIsBetter { get; set; }
    }
}
===== END: PgnTools\Services\EleganceService.cs =====

===== BEGIN: PgnTools\Services\StockfishDownloaderService.cs =====
using System.IO.Compression;
using System.Net;
using System.Net.Http.Headers;
using System.Runtime.Intrinsics.X86;
using System.Text.Json;

namespace PgnTools.Services;

public sealed record StockfishDownloadResult(
    string Tag,
    string Variant,
    string InstallDirectory,
    string ExecutablePath);

public interface IStockfishDownloaderService
{
    StockfishVariant SelectBestVariant();

    Task<StockfishDownloadResult> DownloadLatestAsync(
        IProgress<string>? status = null,
        CancellationToken cancellationToken = default);
}

public enum StockfishVariant
{
    Base,
    Sse41Popcnt,
    Bmi2,
    Avx2,
    Avx512,
    Vnni256,
    Vnni512
}

/// <summary>
/// Downloads the latest Stockfish release from the official GitHub repository,
/// selecting a suitable variant for the current CPU.
/// </summary>
public sealed class StockfishDownloaderService : IStockfishDownloaderService
{
    private const int BufferSize = 65536;
    private const int MaxRetryAttempts = 4;
    private static readonly TimeSpan ReleaseRequestTimeout = TimeSpan.FromSeconds(30);
    private static readonly TimeSpan DownloadRequestTimeout = TimeSpan.FromMinutes(10);
    private static readonly TimeSpan[] RetryDelays =
    [
        TimeSpan.FromMilliseconds(250),
        TimeSpan.FromMilliseconds(500),
        TimeSpan.FromSeconds(1),
        TimeSpan.FromSeconds(2)
    ];
    private static readonly Uri LatestReleaseUri = new("https://api.github.com/repos/official-stockfish/Stockfish/releases/latest");

    private static readonly HttpClient HttpClient = CreateClient();

    public StockfishVariant SelectBestVariant()
    {
        // Prefer the most capable build available on this CPU.
        // Order mirrors the release asset variants.
        if (IsVnni256Supported())
        {
            return StockfishVariant.Vnni256;
        }

        if (IsAvx512Supported())
        {
            return StockfishVariant.Avx512;
        }

        if (Avx2.IsSupported)
        {
            return StockfishVariant.Avx2;
        }

        if (Bmi2.IsSupported)
        {
            return StockfishVariant.Bmi2;
        }

        if (Sse41.IsSupported && Popcnt.IsSupported)
        {
            return StockfishVariant.Sse41Popcnt;
        }

        return StockfishVariant.Base;
    }

    public async Task<StockfishDownloadResult> DownloadLatestAsync(
        IProgress<string>? status = null,
        CancellationToken cancellationToken = default)
    {
        status?.Report("Querying latest Stockfish release...");

        using var response = await SendWithRetryAsync(
            () => CreateGitHubRequest(LatestReleaseUri, expectsJson: true),
            ReleaseRequestTimeout,
            cancellationToken).ConfigureAwait(false);

        if (IsRateLimited(response))
        {
            throw new InvalidOperationException(
                "GitHub API rate limit exceeded. Set PGNTOOLS_GITHUB_TOKEN or GITHUB_TOKEN to increase the limit.");
        }

        response.EnsureSuccessStatusCode();

        await using var jsonStream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
        using var document = await JsonDocument.ParseAsync(jsonStream, cancellationToken: cancellationToken)
            .ConfigureAwait(false);

        var root = document.RootElement;
        var tag = root.GetProperty("tag_name").GetString() ?? "latest";
        var assets = root.GetProperty("assets");

        var variant = SelectBestVariant();
        var asset = SelectAsset(assets, variant);
        if (asset is null)
        {
            throw new InvalidOperationException("No compatible Stockfish Windows asset was found in the latest release.");
        }

        var assetName = asset.Name;
        var downloadUrl = !string.IsNullOrWhiteSpace(asset.BrowserUrl)
            ? asset.BrowserUrl
            : asset.ApiUrl;

        if (string.IsNullOrWhiteSpace(downloadUrl))
        {
            throw new InvalidOperationException($"Download URL not found for asset '{assetName}'.");
        }

        var installDirectory = GetInstallDirectory(tag, variant);
        var stagingDirectory = CreateStagingDirectory(installDirectory);

        var tempZipPath = Path.Combine(Path.GetTempPath(), $"stockfish_{tag}_{Guid.NewGuid():N}.zip");

        try
        {
            status?.Report($"Downloading {assetName}...");

            using var assetResponse = await SendWithRetryAsync(
                () => CreateGitHubRequest(new Uri(downloadUrl), expectsJson: false),
                DownloadRequestTimeout,
                cancellationToken).ConfigureAwait(false);

            if (IsRateLimited(assetResponse))
            {
                throw new InvalidOperationException(
                    "GitHub API rate limit exceeded while downloading the asset. Set PGNTOOLS_GITHUB_TOKEN or GITHUB_TOKEN to increase the limit.");
            }

            assetResponse.EnsureSuccessStatusCode();

            await using var assetStream = await assetResponse.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            await using var fileStream = new FileStream(tempZipPath, FileMode.Create, FileAccess.Write, FileShare.None, BufferSize, FileOptions.Asynchronous);
            await assetStream.CopyToAsync(fileStream, cancellationToken).ConfigureAwait(false);
            await fileStream.FlushAsync(cancellationToken).ConfigureAwait(false);
            fileStream.Flush(true);

            status?.Report("Extracting Stockfish...");
            ExtractZipSafely(tempZipPath, stagingDirectory);

            status?.Report("Locating engine executable...");
            var stagedExePath = FindExecutable(stagingDirectory, variant);
            if (stagedExePath == null)
            {
                throw new FileNotFoundException("Stockfish executable was not found after extraction.", stagingDirectory);
            }

            status?.Report("Finalizing install...");
            ReplaceInstallDirectory(stagingDirectory, installDirectory);

            var exePath = FindExecutable(installDirectory, variant)
                ?? stagedExePath.Replace(stagingDirectory, installDirectory, StringComparison.OrdinalIgnoreCase);

            status?.Report($"Stockfish ready: {Path.GetFileName(exePath)}");

            return new StockfishDownloadResult(tag, variant.ToString(), installDirectory, exePath);
        }
        finally
        {
            TryDeleteDirectory(stagingDirectory);
            try
            {
                if (File.Exists(tempZipPath))
                {
                    File.Delete(tempZipPath);
                }
            }
            catch
            {
            }
        }
    }

    private static HttpClient CreateClient()
    {
        var client = new HttpClient
        {
            Timeout = Timeout.InfiniteTimeSpan
        };

        // GitHub API requires a User-Agent header.
        client.DefaultRequestHeaders.UserAgent.ParseAdd("PgnTools/1.0 (GitHub; PgnTools)");
        return client;
    }

    private static string CreateStagingDirectory(string installDirectory)
    {
        var parent = Path.GetDirectoryName(installDirectory);
        if (string.IsNullOrWhiteSpace(parent))
        {
            parent = Path.GetTempPath();
        }

        var baseName = Path.GetFileName(installDirectory);
        if (string.IsNullOrWhiteSpace(baseName))
        {
            baseName = "stockfish";
        }

        var stagingDirectory = Path.Combine(parent, $"{baseName}.staging.{Guid.NewGuid():N}");
        if (Directory.Exists(stagingDirectory))
        {
            Directory.Delete(stagingDirectory, recursive: true);
        }

        Directory.CreateDirectory(stagingDirectory);
        return stagingDirectory;
    }

    private static void ReplaceInstallDirectory(string stagingDirectory, string installDirectory)
    {
        var backupDirectory = $"{installDirectory}.bak.{Guid.NewGuid():N}";
        if (Directory.Exists(installDirectory))
        {
            Directory.Move(installDirectory, backupDirectory);
        }

        try
        {
            Directory.Move(stagingDirectory, installDirectory);
        }
        catch
        {
            try
            {
                if (Directory.Exists(backupDirectory) && !Directory.Exists(installDirectory))
                {
                    Directory.Move(backupDirectory, installDirectory);
                }
            }
            catch
            {
            }

            throw;
        }

        TryDeleteDirectory(backupDirectory);
    }

    private static void ExtractZipSafely(string zipPath, string destinationDirectory)
    {
        var destinationRoot = NormalizeDirectoryPath(destinationDirectory);

        using var archive = ZipFile.OpenRead(zipPath);
        foreach (var entry in archive.Entries)
        {
            if (string.IsNullOrWhiteSpace(entry.FullName))
            {
                continue;
            }

            var destinationPath = Path.GetFullPath(Path.Combine(destinationRoot, entry.FullName));
            if (!destinationPath.StartsWith(destinationRoot, StringComparison.OrdinalIgnoreCase))
            {
                throw new InvalidOperationException($"Zip entry '{entry.FullName}' is outside the destination directory.");
            }

            if (entry.FullName.EndsWith("/", StringComparison.Ordinal) ||
                entry.FullName.EndsWith("\\", StringComparison.Ordinal))
            {
                Directory.CreateDirectory(destinationPath);
                continue;
            }

            var destinationParent = Path.GetDirectoryName(destinationPath);
            if (!string.IsNullOrWhiteSpace(destinationParent))
            {
                Directory.CreateDirectory(destinationParent);
            }

            entry.ExtractToFile(destinationPath, overwrite: true);
        }
    }

    private static string NormalizeDirectoryPath(string path)
    {
        var fullPath = Path.GetFullPath(path);
        if (!fullPath.EndsWith(Path.DirectorySeparatorChar.ToString(), StringComparison.Ordinal))
        {
            fullPath += Path.DirectorySeparatorChar;
        }

        return fullPath;
    }

    private static void TryDeleteDirectory(string directory)
    {
        try
        {
            if (Directory.Exists(directory))
            {
                Directory.Delete(directory, recursive: true);
            }
        }
        catch
        {
        }
    }

    private static AssetInfo? SelectAsset(JsonElement assets, StockfishVariant preferredVariant)
    {
        var assetsList = assets.EnumerateArray()
            .Select(a => new
            {
                Name = a.GetProperty("name").GetString(),
                ApiUrl = a.TryGetProperty("url", out var apiUrl) ? apiUrl.GetString() : null,
                BrowserUrl = a.TryGetProperty("browser_download_url", out var browserUrl) ? browserUrl.GetString() : null
            })
            .Where(a => !string.IsNullOrWhiteSpace(a.Name) &&
                        (!string.IsNullOrWhiteSpace(a.ApiUrl) || !string.IsNullOrWhiteSpace(a.BrowserUrl)))
            .Select(a => new AssetInfo(a.Name!, a.ApiUrl ?? string.Empty, a.BrowserUrl ?? string.Empty))
            .ToList();

        if (assetsList.Count == 0)
        {
            return null;
        }

        var preferredNames = GetVariantAssetNamesInPriority(preferredVariant);
        foreach (var name in preferredNames)
        {
            var match = assetsList.FirstOrDefault(a => string.Equals(a.Name, name, StringComparison.OrdinalIgnoreCase));
            if (match != null)
            {
                return match;
            }
        }

        // Final fallback: any stockfish Windows x64 zip.
        var fallback = assetsList.FirstOrDefault(a =>
            a.Name!.StartsWith("stockfish-windows-x86-64", StringComparison.OrdinalIgnoreCase) &&
            a.Name.EndsWith(".zip", StringComparison.OrdinalIgnoreCase));

        return fallback;
    }

    private static IReadOnlyList<string> GetVariantAssetNamesInPriority(StockfishVariant variant)
    {
        // Order: preferred variant first, then progressively more general options.
        var variants = variant switch
        {
            StockfishVariant.Vnni512 => new[]
            {
                "stockfish-windows-x86-64-vnni512.zip",
                "stockfish-windows-x86-64-vnni256.zip",
                "stockfish-windows-x86-64-avx512.zip",
                "stockfish-windows-x86-64-avx2.zip",
                "stockfish-windows-x86-64-bmi2.zip",
                "stockfish-windows-x86-64-sse41-popcnt.zip",
                "stockfish-windows-x86-64.zip"
            },
            StockfishVariant.Vnni256 => new[]
            {
                "stockfish-windows-x86-64-vnni256.zip",
                "stockfish-windows-x86-64-avx512.zip",
                "stockfish-windows-x86-64-avx2.zip",
                "stockfish-windows-x86-64-bmi2.zip",
                "stockfish-windows-x86-64-sse41-popcnt.zip",
                "stockfish-windows-x86-64.zip"
            },
            StockfishVariant.Avx512 => new[]
            {
                "stockfish-windows-x86-64-avx512.zip",
                "stockfish-windows-x86-64-avx2.zip",
                "stockfish-windows-x86-64-bmi2.zip",
                "stockfish-windows-x86-64-sse41-popcnt.zip",
                "stockfish-windows-x86-64.zip"
            },
            StockfishVariant.Avx2 => new[]
            {
                "stockfish-windows-x86-64-avx2.zip",
                "stockfish-windows-x86-64-bmi2.zip",
                "stockfish-windows-x86-64-sse41-popcnt.zip",
                "stockfish-windows-x86-64.zip"
            },
            StockfishVariant.Bmi2 => new[]
            {
                "stockfish-windows-x86-64-bmi2.zip",
                "stockfish-windows-x86-64-sse41-popcnt.zip",
                "stockfish-windows-x86-64.zip"
            },
            StockfishVariant.Sse41Popcnt => new[]
            {
                "stockfish-windows-x86-64-sse41-popcnt.zip",
                "stockfish-windows-x86-64.zip"
            },
            _ => new[]
            {
                "stockfish-windows-x86-64.zip",
                "stockfish-windows-x86-64-sse41-popcnt.zip"
            }
        };

        return variants;
    }

    private static string GetInstallDirectory(string tag, StockfishVariant variant)
    {
        var variantSegment = variant.ToString().ToLowerInvariant();

        var assetsPreferred = Path.Combine(
            AppContext.BaseDirectory,
            "Assets",
            "stockfish",
            tag,
            variantSegment);

        if (CanWriteToDirectory(assetsPreferred))
        {
            return assetsPreferred;
        }

        return Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "PgnTools",
            "Stockfish",
            tag,
            variantSegment);
    }

    private static bool CanWriteToDirectory(string directoryPath)
    {
        try
        {
            Directory.CreateDirectory(directoryPath);
            var probePath = Path.Combine(directoryPath, $".write_probe_{Guid.NewGuid():N}.tmp");
            using (new FileStream(probePath, FileMode.CreateNew, FileAccess.Write, FileShare.None))
            {
            }

            File.Delete(probePath);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static string? FindExecutable(string installDirectory, StockfishVariant variant)
    {
        var exes = Directory.EnumerateFiles(installDirectory, "*.exe", SearchOption.AllDirectories)
            .Where(p => Path.GetFileName(p).Contains("stockfish", StringComparison.OrdinalIgnoreCase))
            .ToList();

        if (exes.Count == 0)
        {
            return null;
        }

        var variantToken = variant.ToString().ToLowerInvariant();

        var preferred = exes
            .Where(p => Path.GetFileName(p).Contains(variantToken, StringComparison.OrdinalIgnoreCase))
            .OrderBy(p => p.Length)
            .ThenBy(p => p, StringComparer.OrdinalIgnoreCase)
            .FirstOrDefault();

        if (!string.IsNullOrWhiteSpace(preferred))
        {
            return preferred;
        }

        return exes
            .OrderBy(p => p.Length)
            .ThenBy(p => p, StringComparer.OrdinalIgnoreCase)
            .First();
    }

    private static bool IsAvx512Supported()
    {
#if NET8_0_OR_GREATER
        return Avx512F.IsSupported;
#else
        return false;
#endif
    }

    private static bool IsVnni256Supported()
    {
#if NET8_0_OR_GREATER
        return AvxVnni.IsSupported;
#else
        return false;
#endif
    }

    private static HttpRequestMessage CreateGitHubRequest(Uri uri, bool expectsJson)
    {
        var request = new HttpRequestMessage(HttpMethod.Get, uri)
        {
            VersionPolicy = HttpVersionPolicy.RequestVersionOrHigher,
            Version = HttpVersion.Version20
        };

        request.Headers.Accept.Clear();
        request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(
            expectsJson ? "application/vnd.github+json" : "application/octet-stream"));
        request.Headers.UserAgent.ParseAdd("PgnTools/1.0 (GitHub; PgnTools)");
        request.Headers.TryAddWithoutValidation("X-GitHub-Api-Version", "2022-11-28");

        var token = GetGitHubToken();
        if (!string.IsNullOrWhiteSpace(token))
        {
            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
        }

        return request;
    }

    private static string? GetGitHubToken()
    {
        var token = Environment.GetEnvironmentVariable("PGNTOOLS_GITHUB_TOKEN");
        if (!string.IsNullOrWhiteSpace(token))
        {
            return token;
        }

        token = Environment.GetEnvironmentVariable("GITHUB_TOKEN");
        if (!string.IsNullOrWhiteSpace(token))
        {
            return token;
        }

        token = Environment.GetEnvironmentVariable("GH_TOKEN");
        return string.IsNullOrWhiteSpace(token) ? null : token;
    }

    private static async Task<HttpResponseMessage> SendWithRetryAsync(
        Func<HttpRequestMessage> requestFactory,
        TimeSpan timeout,
        CancellationToken cancellationToken)
    {
        var lastException = (Exception?)null;

        for (var attempt = 1; attempt <= MaxRetryAttempts; attempt++)
        {
            using var attemptCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            attemptCts.CancelAfter(timeout);

            using var request = requestFactory();
            try
            {
                var response = await HttpClient.SendAsync(
                        request,
                        HttpCompletionOption.ResponseHeadersRead,
                        attemptCts.Token)
                    .ConfigureAwait(false);

                if (!IsTransientStatusCode(response.StatusCode) || attempt == MaxRetryAttempts)
                {
                    return response;
                }

                response.Dispose();
            }
            catch (OperationCanceledException) when (!cancellationToken.IsCancellationRequested && attempt < MaxRetryAttempts)
            {
                lastException = new TimeoutException("Request timed out.");
            }
            catch (HttpRequestException ex) when (attempt < MaxRetryAttempts)
            {
                lastException = ex;
            }

            var delay = GetRetryDelay(attempt);
            await Task.Delay(delay, cancellationToken).ConfigureAwait(false);
        }

        throw new InvalidOperationException("Failed to reach GitHub after multiple attempts.", lastException);
    }

    private static TimeSpan GetRetryDelay(int attempt)
    {
        if (attempt <= 0 || attempt > RetryDelays.Length)
        {
            return TimeSpan.FromSeconds(2);
        }

        return RetryDelays[attempt - 1];
    }

    private static bool IsTransientStatusCode(HttpStatusCode statusCode)
    {
        return statusCode == HttpStatusCode.RequestTimeout ||
               statusCode == HttpStatusCode.TooManyRequests ||
               statusCode == HttpStatusCode.InternalServerError ||
               statusCode == HttpStatusCode.BadGateway ||
               statusCode == HttpStatusCode.ServiceUnavailable ||
               statusCode == HttpStatusCode.GatewayTimeout;
    }

    private static bool IsRateLimited(HttpResponseMessage response)
    {
        if (response.StatusCode != HttpStatusCode.Forbidden)
        {
            return false;
        }

        if (!response.Headers.TryGetValues("X-RateLimit-Remaining", out var remaining))
        {
            return false;
        }

        foreach (var value in remaining)
        {
            if (string.Equals(value, "0", StringComparison.Ordinal))
            {
                return true;
            }
        }

        return false;
    }

    private sealed record AssetInfo(string Name, string ApiUrl, string BrowserUrl);
}
===== END: PgnTools\Services\StockfishDownloaderService.cs =====

===== BEGIN: PgnTools\ViewModels\Tools\ChessAnalyzerViewModel.cs =====
using System.IO;

namespace PgnTools.ViewModels.Tools;

/// <summary>
/// ViewModel for the Chess Analyzer tool.
/// </summary>
public partial class ChessAnalyzerViewModel(
    IChessAnalyzerService chessAnalyzerService,
    IStockfishDownloaderService stockfishDownloaderService,
    IWindowService windowService,
    IAppSettingsService settings) : BaseViewModel, IInitializable, IDisposable
{
    private readonly IChessAnalyzerService _chessAnalyzerService = chessAnalyzerService;
    private readonly IStockfishDownloaderService _stockfishDownloaderService = stockfishDownloaderService;
    private readonly IAppSettingsService _settings = settings;
    private readonly IWindowService _windowService = windowService;
    private CancellationTokenSource? _cancellationTokenSource;
    private readonly SemaphoreSlim _executionLock = new(1, 1);
    private bool _disposed;
    private bool _disposeWhenIdle;
    private long _progressGames;
    private long _progressTotal;
    private const string SettingsPrefix = nameof(ChessAnalyzerViewModel);

    [ObservableProperty]
    private string _inputFilePath = string.Empty;

    [ObservableProperty]
    private string _inputFileName = string.Empty;

    [ObservableProperty]
    private string _enginePath = string.Empty;

    [ObservableProperty]
    private string _engineName = string.Empty;

    [ObservableProperty]
    private string _outputFilePath = string.Empty;

    [ObservableProperty]
    private string _outputFileName = string.Empty;

    [ObservableProperty]
    private int _depth = 18;

    [ObservableProperty]
    private bool _addEleganceTags;

    [ObservableProperty]
    private bool _useTablebases;

    [ObservableProperty]
    private string _tablebasePath = string.Empty;

    [ObservableProperty]
    private bool _isRunning;

    [ObservableProperty]
    private double _progressValue;

    [ObservableProperty]
    private string _statusMessage = "Select an input PGN and a UCI engine (e.g., Stockfish)";
    public void Initialize()
    {
        Title = "Chess Analyzer";
        StatusSeverity = InfoBarSeverity.Informational;
        LoadState();
    }
    [RelayCommand]
    private async Task SelectInputFileAsync()
    {
        try
        {
            var file = await FilePickerHelper.PickSingleFileAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.Input",
                ".pgn");
            if (file == null)
            {
                return;
    }
            var validation = await FileValidationHelper.ValidateReadableFileAsync(file);
            if (!validation.Success)
            {
                StatusMessage = $"Cannot access file: {validation.ErrorMessage}";
                StatusSeverity = InfoBarSeverity.Error;
                return;
    }
            InputFilePath = file.Path;
            InputFileName = file.Name;
            StatusMessage = $"Selected input: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;

            if (string.IsNullOrWhiteSpace(OutputFilePath))
            {
                var directory = Path.GetDirectoryName(InputFilePath) ?? string.Empty;
                var suggestedName = $"{Path.GetFileNameWithoutExtension(InputFilePath)}_analyzed.pgn";
                OutputFilePath = Path.Combine(directory, suggestedName);
                OutputFileName = Path.GetFileName(OutputFilePath);
    }
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting input file: {ex.Message}";
    }
    }

    [RelayCommand]
    private async Task SelectEngineAsync()
    {
        try
        {
            var file = await FilePickerHelper.PickSingleFileAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.Engine",
                ".exe");
            if (file == null)
            {
                return;
    }
            var validation = await FileValidationHelper.ValidateReadableFileAsync(file);
            if (!validation.Success)
            {
                StatusMessage = $"Cannot access engine: {validation.ErrorMessage}";
                StatusSeverity = InfoBarSeverity.Error;
                return;
    }
            EnginePath = file.Path;
            EngineName = file.Name;
            StatusMessage = $"Selected engine: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting engine: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand(CanExecute = nameof(CanDownloadLatestEngine))]
    private async Task DownloadLatestEngineAsync()
    {
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            StatusMessage = "Preparing Stockfish download...";
            StatusSeverity = InfoBarSeverity.Informational;
            ProgressValue = 0;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail(0);

            _cancellationTokenSource = new CancellationTokenSource();

            var statusProgress = new Progress<string>(message =>
            {
                StatusMessage = message;
                StatusDetail = BuildProgressDetail(ProgressValue);
            });

            var result = await _stockfishDownloaderService.DownloadLatestAsync(
                statusProgress,
                _cancellationTokenSource.Token);

            EnginePath = result.ExecutablePath;
            EngineName = Path.GetFileName(result.ExecutablePath);
            StatusMessage = $"Stockfish downloaded ({result.Tag}, {result.Variant}).";
            StatusSeverity = InfoBarSeverity.Success;
            StatusDetail = BuildProgressDetail(100);
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "Stockfish download cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error downloading Stockfish: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
            TryDisposeWhenIdle();
    }
    }

    [RelayCommand]
    private async Task SelectOutputFileAsync()
    {
        try
        {
            var suggestedName = string.IsNullOrWhiteSpace(InputFilePath)
                ? "analyzed.pgn"
                : $"{Path.GetFileNameWithoutExtension(InputFilePath)}_analyzed.pgn";

            var file = await FilePickerHelper.PickSaveFileAsync(
                _windowService.WindowHandle,
                suggestedName,
                new Dictionary<string, IList<string>>
                {
                    { "PGN Files", [".pgn"] }
                },
                $"{SettingsPrefix}.Picker.Output");

            if (file == null)
            {
                return;
    }
            OutputFilePath = file.Path;
            OutputFileName = file.Name;
            StatusMessage = $"Selected output: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting output file: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand]
    private async Task SelectTablebaseFolderAsync()
    {
        try
        {
            var folder = await FilePickerHelper.PickFolderAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.Tablebases");
            if (folder == null)
            {
                return;
    }
            TablebasePath = folder.Path;
            UseTablebases = true;
            StatusMessage = $"Selected tablebase folder: {folder.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting tablebase folder: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    private bool CanDownloadLatestEngine() => !IsRunning;

    [RelayCommand(CanExecute = nameof(CanRun))]
    private async Task RunAsync()
    {
        if (string.IsNullOrWhiteSpace(InputFilePath) ||
            string.IsNullOrWhiteSpace(EnginePath) ||
            string.IsNullOrWhiteSpace(OutputFilePath))
        {
            return;
    }
        var inputFullPath = Path.GetFullPath(InputFilePath);
        var outputFullPath = Path.GetFullPath(OutputFilePath);
        if (string.Equals(inputFullPath, outputFullPath, StringComparison.OrdinalIgnoreCase))
        {
            StatusMessage = "Input and output files must be different.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (Depth <= 0)
        {
            StatusMessage = "Depth must be greater than zero.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (!File.Exists(EnginePath))
        {
            StatusMessage = "Engine executable not found.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (UseTablebases && (string.IsNullOrWhiteSpace(TablebasePath) || !Directory.Exists(TablebasePath)))
        {
            StatusMessage = "Tablebase folder not found.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            ProgressValue = 0;
            StatusMessage = "Initializing engine...";
            StatusSeverity = InfoBarSeverity.Informational;
            _progressGames = 0;
            _progressTotal = 0;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail(0);

            _cancellationTokenSource = new CancellationTokenSource();

            var progress = new Progress<AnalyzerProgress>(p =>
            {
                Interlocked.Exchange(ref _progressGames, p.ProcessedGames);
                Interlocked.Exchange(ref _progressTotal, p.TotalGames);
                ProgressValue = p.Percent;
                StatusMessage = $"Analyzing games... {p.Percent:0}%";
                StatusDetail = BuildProgressDetail(p.Percent, p.ProcessedGames, p.TotalGames, "games");
            });

            await _chessAnalyzerService.AnalyzePgnAsync(
                InputFilePath,
                OutputFilePath,
                EnginePath,
                Depth,
                UseTablebases ? TablebasePath : null,
                progress,
                _cancellationTokenSource.Token,
                AddEleganceTags);

            if (_cancellationTokenSource?.IsCancellationRequested == true)
            {
                throw new OperationCanceledException(_cancellationTokenSource.Token);
    }
            ProgressValue = 100;
            StatusMessage = AddEleganceTags
                ? "Analysis and Elegance tagging complete. (Move-by-move evals require SAN/FEN support.)"
                : "Analysis complete. (Move-by-move evals require SAN/FEN support.)";
            StatusSeverity = InfoBarSeverity.Success;
            StatusDetail = BuildProgressDetail(100, _progressTotal > 0 ? _progressTotal : _progressGames, _progressTotal, "games");
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "Analysis cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            ProgressValue = 0;
            StatusDetail = BuildProgressDetail(ProgressValue, _progressGames, _progressTotal, "games");
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail(ProgressValue, _progressGames, _progressTotal, "games");
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
            TryDisposeWhenIdle();
    }
    }

    private bool CanRun() =>
        !IsRunning &&
        !string.IsNullOrWhiteSpace(InputFilePath) &&
        !string.IsNullOrWhiteSpace(EnginePath) &&
        !string.IsNullOrWhiteSpace(OutputFilePath) &&
        File.Exists(InputFilePath) &&
        File.Exists(EnginePath) &&
        (!UseTablebases || (!string.IsNullOrWhiteSpace(TablebasePath) && Directory.Exists(TablebasePath)));

    [RelayCommand]
    private void Cancel()
    {
        _cancellationTokenSource?.Cancel();
        StatusMessage = "Cancelling... finishing current game.";
        StatusSeverity = InfoBarSeverity.Warning;
        StatusDetail = BuildProgressDetail(ProgressValue);
    }
    partial void OnInputFilePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnEnginePathChanged(string value)
    {
        if (!string.IsNullOrWhiteSpace(value) && !File.Exists(value))
        {
            StatusMessage = "Engine executable not found.";
            StatusSeverity = InfoBarSeverity.Error;
    }
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnOutputFilePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnDepthChanged(int value)
    {
        const int minDepth = 1;
        const int maxDepth = 50;

        if (value < minDepth)
        {
            Depth = minDepth;
            return;
    }
        if (value > maxDepth)
        {
            Depth = maxDepth;
            return;
    }
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnUseTablebasesChanged(bool value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnTablebasePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnIsRunningChanged(bool value)
    {
        RunCommand.NotifyCanExecuteChanged();
        DownloadLatestEngineCommand.NotifyCanExecuteChanged();
    }
    public void Dispose()
    {
        if (_disposed)
        {
            return;
    }
        _disposed = true;
        SaveState();
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        _cancellationTokenSource = null;
        _executionLock.Dispose();
    }

    public void DisposeWhenIdle()
    {
        if (_disposed)
        {
            return;
        }

        if (IsRunning)
        {
            _disposeWhenIdle = true;
            return;
        }

        Dispose();
    }

    private void TryDisposeWhenIdle()
    {
        if (_disposeWhenIdle && !_disposed && !IsRunning)
        {
            _disposeWhenIdle = false;
            Dispose();
        }
    }
    private void LoadState()
    {
        InputFilePath = _settings.GetValue($"{SettingsPrefix}.{nameof(InputFilePath)}", string.Empty);
        if (!string.IsNullOrWhiteSpace(InputFilePath) && File.Exists(InputFilePath))
        {
            InputFileName = Path.GetFileName(InputFilePath);
    }
        else
        {
            InputFilePath = string.Empty;
            InputFileName = string.Empty;
    }
        EnginePath = _settings.GetValue($"{SettingsPrefix}.{nameof(EnginePath)}", string.Empty);
        if (!string.IsNullOrWhiteSpace(EnginePath) && !File.Exists(EnginePath))
        {
            EnginePath = string.Empty;
    }
        if (string.IsNullOrWhiteSpace(EnginePath) || IsTemporaryPath(EnginePath))
        {
            var preferredEnginePath = ResolvePreferredEnginePath();
            if (!string.IsNullOrWhiteSpace(preferredEnginePath))
            {
                EnginePath = preferredEnginePath;
    }
        }

        EngineName = !string.IsNullOrWhiteSpace(EnginePath) && File.Exists(EnginePath)
            ? Path.GetFileName(EnginePath)
            : string.Empty;

        OutputFilePath = _settings.GetValue($"{SettingsPrefix}.{nameof(OutputFilePath)}", string.Empty);
        OutputFileName = string.IsNullOrWhiteSpace(OutputFilePath) ? string.Empty : Path.GetFileName(OutputFilePath);

        Depth = _settings.GetValue($"{SettingsPrefix}.{nameof(Depth)}", Depth);
        AddEleganceTags = _settings.GetValue($"{SettingsPrefix}.{nameof(AddEleganceTags)}", AddEleganceTags);
        UseTablebases = _settings.GetValue($"{SettingsPrefix}.{nameof(UseTablebases)}", UseTablebases);
        TablebasePath = _settings.GetValue($"{SettingsPrefix}.{nameof(TablebasePath)}", TablebasePath);
        if (!string.IsNullOrWhiteSpace(TablebasePath) && !Directory.Exists(TablebasePath))
        {
            TablebasePath = string.Empty;
            UseTablebases = false;
    }
    }

    private void SaveState()
    {
        _settings.SetValue($"{SettingsPrefix}.{nameof(InputFilePath)}", InputFilePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(EnginePath)}", EnginePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(OutputFilePath)}", OutputFilePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(Depth)}", Depth);
        _settings.SetValue($"{SettingsPrefix}.{nameof(AddEleganceTags)}", AddEleganceTags);
        _settings.SetValue($"{SettingsPrefix}.{nameof(UseTablebases)}", UseTablebases);
        _settings.SetValue($"{SettingsPrefix}.{nameof(TablebasePath)}", TablebasePath);
    }
    private static string ResolvePreferredEnginePath()
    {
        var assetsRoot = Path.Combine(AppContext.BaseDirectory, "Assets");
        var assetsCandidate = FindStockfishExeUnder(assetsRoot);
        if (!string.IsNullOrWhiteSpace(assetsCandidate))
        {
            return assetsCandidate;
    }
        var localAppDataRoot = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "PgnTools",
            "Stockfish");

        return FindStockfishExeUnder(localAppDataRoot) ?? string.Empty;
    }
    private static string? FindStockfishExeUnder(string rootPath)
    {
        if (string.IsNullOrWhiteSpace(rootPath) || !Directory.Exists(rootPath))
        {
            return null;
    }
        try
        {
            return Directory.EnumerateFiles(rootPath, "*.exe", SearchOption.AllDirectories)
                .Where(path => Path.GetFileName(path).Contains("stockfish", StringComparison.OrdinalIgnoreCase))
                .OrderBy(path => path.Contains($"{Path.DirectorySeparatorChar}Assets{Path.DirectorySeparatorChar}stockfish{Path.DirectorySeparatorChar}", StringComparison.OrdinalIgnoreCase) ? 0 : 1)
                .ThenByDescending(File.GetLastWriteTimeUtc)
                .ThenBy(path => path.Length)
                .FirstOrDefault();
    }
        catch
        {
            return null;
    }
    }

    private static bool IsTemporaryPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return false;
    }
        var tempRoot = Path.GetFullPath(Path.GetTempPath()).TrimEnd(Path.DirectorySeparatorChar);
        var fullPath = Path.GetFullPath(path);
        return fullPath.StartsWith(tempRoot, StringComparison.OrdinalIgnoreCase);
    }
}






===== END: PgnTools\ViewModels\Tools\ChessAnalyzerViewModel.cs =====

===== BEGIN: PgnTools\ViewModels\Tools\EleganceViewModel.cs =====
using System.IO;

namespace PgnTools.ViewModels.Tools;

/// <summary>
/// ViewModel for the Elegance tool.
/// </summary>
public partial class EleganceViewModel(
    IEleganceService eleganceService,
    IEleganceGoldenValidationService goldenValidationService,
    IStockfishDownloaderService stockfishDownloaderService,
    IWindowService windowService,
    IAppSettingsService settings) : BaseViewModel, IInitializable, IDisposable
{
    private readonly IEleganceService _eleganceService = eleganceService;
    private readonly IEleganceGoldenValidationService _goldenValidationService = goldenValidationService;
    private readonly IStockfishDownloaderService _stockfishDownloaderService = stockfishDownloaderService;
    private readonly IAppSettingsService _settings = settings;
    private readonly IWindowService _windowService = windowService;
    private CancellationTokenSource? _cancellationTokenSource;
    private readonly SemaphoreSlim _executionLock = new(1, 1);
    private bool _disposed;
    private const string SettingsPrefix = nameof(EleganceViewModel);

    [ObservableProperty]
    private string _inputFilePath = string.Empty;

    [ObservableProperty]
    private string _inputFileName = string.Empty;

    [ObservableProperty]
    private string _enginePath = string.Empty;

    [ObservableProperty]
    private string _engineName = string.Empty;

    [ObservableProperty]
    private string _outputFilePath = string.Empty;

    [ObservableProperty]
    private string _outputFileName = string.Empty;

    [ObservableProperty]
    private int _depth = 14;

    [ObservableProperty]
    private bool _isRunning;

    [ObservableProperty]
    private string _statusMessage = "Select input/output PGN files and a UCI engine";

    [ObservableProperty]
    private double _progressValue;
    public void Initialize()
    {
        Title = "Elegance";
        StatusSeverity = InfoBarSeverity.Informational;
        LoadState();
    }
    [RelayCommand]
    private async Task SelectInputFileAsync()
    {
        try
        {
            var file = await FilePickerHelper.PickSingleFileAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.Input",
                ".pgn");
            if (file == null)
            {
                return;
    }
            var validation = await FileValidationHelper.ValidateReadableFileAsync(file);
            if (!validation.Success)
            {
                StatusMessage = $"Cannot access file: {validation.ErrorMessage}";
                StatusSeverity = InfoBarSeverity.Error;
                return;
    }
            InputFilePath = file.Path;
            InputFileName = file.Name;
            StatusMessage = $"Selected input: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;

            if (string.IsNullOrWhiteSpace(OutputFilePath))
            {
                var directory = Path.GetDirectoryName(InputFilePath) ?? string.Empty;
                var suggestedName = $"{Path.GetFileNameWithoutExtension(InputFilePath)}-elegance.pgn";
                OutputFilePath = Path.Combine(directory, suggestedName);
                OutputFileName = Path.GetFileName(OutputFilePath);
    }
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting input file: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand]
    private async Task SelectEngineAsync()
    {
        try
        {
            var file = await FilePickerHelper.PickSingleFileAsync(
                _windowService.WindowHandle,
                $"{SettingsPrefix}.Picker.Engine",
                ".exe");
            if (file == null)
            {
                return;
    }
            var validation = await FileValidationHelper.ValidateReadableFileAsync(file);
            if (!validation.Success)
            {
                StatusMessage = $"Cannot access engine: {validation.ErrorMessage}";
                StatusSeverity = InfoBarSeverity.Error;
                return;
    }
            EnginePath = file.Path;
            EngineName = file.Name;
            StatusMessage = $"Selected engine: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting engine: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand(CanExecute = nameof(CanDownloadLatestEngine))]
    private async Task DownloadLatestEngineAsync()
    {
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            StatusMessage = "Preparing Stockfish download...";
            StatusSeverity = InfoBarSeverity.Informational;
            ProgressValue = 0;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail(0);

            _cancellationTokenSource = new CancellationTokenSource();

            var statusProgress = new Progress<string>(message =>
            {
                StatusMessage = message;
                StatusDetail = BuildProgressDetail(ProgressValue);
            });

            var result = await _stockfishDownloaderService.DownloadLatestAsync(
                statusProgress,
                _cancellationTokenSource.Token);

            EnginePath = result.ExecutablePath;
            EngineName = Path.GetFileName(result.ExecutablePath);
            StatusMessage = $"Stockfish downloaded ({result.Tag}, {result.Variant}).";
            StatusSeverity = InfoBarSeverity.Success;
            StatusDetail = BuildProgressDetail(100);
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "Stockfish download cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error downloading Stockfish: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
    }
    }

    [RelayCommand]
    private async Task SelectOutputFileAsync()
    {
        try
        {
            var suggestedName = string.IsNullOrWhiteSpace(InputFilePath)
                ? "output-elegance.pgn"
                : $"{Path.GetFileNameWithoutExtension(InputFilePath)}-elegance.pgn";

            var file = await FilePickerHelper.PickSaveFileAsync(
                _windowService.WindowHandle,
                suggestedName,
                new Dictionary<string, IList<string>>
                {
                    { "PGN Files", [".pgn"] }
                },
                $"{SettingsPrefix}.Picker.Output");

            if (file == null)
            {
                return;
    }
            OutputFilePath = file.Path;
            OutputFileName = file.Name;
            StatusMessage = $"Selected output: {file.Name}";
            StatusSeverity = InfoBarSeverity.Informational;
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting output file: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand(CanExecute = nameof(CanRun))]
    private async Task RunAsync()
    {
        if (string.IsNullOrWhiteSpace(InputFilePath) ||
            string.IsNullOrWhiteSpace(EnginePath) ||
            string.IsNullOrWhiteSpace(OutputFilePath))
        {
            return;
    }
        var inputFullPath = Path.GetFullPath(InputFilePath);
        var outputFullPath = Path.GetFullPath(OutputFilePath);
        if (string.Equals(inputFullPath, outputFullPath, StringComparison.OrdinalIgnoreCase))
        {
            StatusMessage = "Input and output files must be different.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (Depth <= 0)
        {
            StatusMessage = "Depth must be greater than zero.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (!File.Exists(EnginePath))
        {
            StatusMessage = "Engine executable not found.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            ProgressValue = 0;
            StatusMessage = "Running engine analysis and scoring elegance...";
            StatusSeverity = InfoBarSeverity.Informational;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail(0);

            _cancellationTokenSource = new CancellationTokenSource();

            var progress = new Progress<double>(p =>
            {
                ProgressValue = p;
                StatusMessage = $"Analyzing and scoring... {p:0}%";
                StatusDetail = BuildProgressDetail(p);
            });

            var result = await _eleganceService.TagEleganceAsync(
                InputFilePath,
                OutputFilePath,
                EnginePath,
                Depth,
                progress,
                _cancellationTokenSource.Token);

            if (result.ProcessedGames == 0)
            {
                StatusMessage = "No games found.";
                StatusSeverity = InfoBarSeverity.Warning;
                StatusDetail = BuildProgressDetail(100, 0, null, "games");
                return;
    }
            StatusMessage =
                $"Completed! Tagged {result.ProcessedGames:N0} games • Avg {result.AverageScore:0.0}" +
                $" (S:{result.AverageSoundness:0.0} C:{result.AverageCoherence:0.0} T:{result.AverageTactical:0.0} Q:{result.AverageQuiet:0.0})";
            StatusSeverity = InfoBarSeverity.Success;
            StatusDetail = BuildProgressDetail(100, result.ProcessedGames, null, "games");
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "Elegance tagging cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            ProgressValue = 0;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
    }
    }

    [RelayCommand(CanExecute = nameof(CanValidateGoldens))]
    private async Task ValidateGoldensAsync()
    {
        if (string.IsNullOrWhiteSpace(EnginePath) || !File.Exists(EnginePath))
        {
            StatusMessage = "Select a valid engine first.";
            StatusSeverity = InfoBarSeverity.Error;
            return;
    }
        var manifestPath = Path.Combine(AppContext.BaseDirectory, "Assets", "elegance-goldens.json");
        if (!File.Exists(manifestPath))
        {
            StatusMessage = "Golden manifest not found: Assets/elegance-goldens.json";
            StatusSeverity = InfoBarSeverity.Warning;
            return;
    }
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            ProgressValue = 0;
            StatusMessage = "Running golden validation...";
            StatusSeverity = InfoBarSeverity.Informational;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail(0);

            _cancellationTokenSource = new CancellationTokenSource();

            var statusProgress = new Progress<string>(message =>
            {
                StatusMessage = message;
                StatusDetail = BuildProgressDetail(ProgressValue);
            });

            var summary = await _goldenValidationService.ValidateAsync(
                manifestPath,
                EnginePath,
                Depth,
                statusProgress,
                _cancellationTokenSource.Token);

            ProgressValue = 100;

            if (summary.Total == 0)
            {
                StatusMessage = "No golden cases found in manifest.";
                StatusSeverity = InfoBarSeverity.Warning;
                StatusDetail = BuildProgressDetail(100, 0, null, "cases");
                return;
    }
            var failed = summary.Cases.Where(c => !c.Passed).ToList();
            if (failed.Count == 0)
            {
                StatusMessage = $"Golden validation passed ({summary.Passed}/{summary.Total}).";
                StatusSeverity = InfoBarSeverity.Success;
                StatusDetail = BuildProgressDetail(100, summary.Total, summary.Total, "cases");
                return;
    }
            var firstFailure = failed[0];
            StatusMessage = $"Golden validation failed ({summary.Passed}/{summary.Total}). First: {firstFailure.Name} -> {firstFailure.Message}";
            StatusSeverity = InfoBarSeverity.Warning;
            StatusDetail = BuildProgressDetail(100, summary.Total, summary.Total, "cases");
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "Golden validation cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error validating goldens: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail(ProgressValue);
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
    }
    }

    private bool CanRun() =>
        !IsRunning &&
        !string.IsNullOrWhiteSpace(InputFilePath) &&
        !string.IsNullOrWhiteSpace(EnginePath) &&
        !string.IsNullOrWhiteSpace(OutputFilePath) &&
        File.Exists(InputFilePath) &&
        File.Exists(EnginePath) &&
        Depth > 0;

    private bool CanValidateGoldens() =>
        !IsRunning &&
        !string.IsNullOrWhiteSpace(EnginePath) &&
        File.Exists(EnginePath) &&
        Depth > 0;

    private bool CanDownloadLatestEngine() => !IsRunning;

    [RelayCommand]
    private void Cancel()
    {
        _cancellationTokenSource?.Cancel();
        StatusMessage = "Cancelling...";
        StatusSeverity = InfoBarSeverity.Warning;
        StatusDetail = BuildProgressDetail(ProgressValue);
    }
    partial void OnInputFilePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnEnginePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
        ValidateGoldensCommand.NotifyCanExecuteChanged();
    }
    partial void OnOutputFilePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
        ValidateGoldensCommand.NotifyCanExecuteChanged();
    }
    partial void OnDepthChanged(int value)
    {
        const int minDepth = 1;
        const int maxDepth = 50;

        if (value < minDepth)
        {
            Depth = minDepth;
            return;
    }
        if (value > maxDepth)
        {
            Depth = maxDepth;
            return;
    }
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnIsRunningChanged(bool value)
    {
        RunCommand.NotifyCanExecuteChanged();
        ValidateGoldensCommand.NotifyCanExecuteChanged();
        DownloadLatestEngineCommand.NotifyCanExecuteChanged();
    }
    public void Dispose()
    {
        if (_disposed)
        {
            return;
    }
        _disposed = true;
        SaveState();
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        _cancellationTokenSource = null;
        _executionLock.Dispose();
    }
    private void LoadState()
    {
        InputFilePath = _settings.GetValue($"{SettingsPrefix}.{nameof(InputFilePath)}", string.Empty);
        if (!string.IsNullOrWhiteSpace(InputFilePath) && File.Exists(InputFilePath))
        {
            InputFileName = Path.GetFileName(InputFilePath);
    }
        else
        {
            InputFilePath = string.Empty;
            InputFileName = string.Empty;
    }
        EnginePath = _settings.GetValue($"{SettingsPrefix}.{nameof(EnginePath)}", string.Empty);
        if (!string.IsNullOrWhiteSpace(EnginePath) && !File.Exists(EnginePath))
        {
            EnginePath = string.Empty;
    }
        if (string.IsNullOrWhiteSpace(EnginePath) || IsTemporaryPath(EnginePath))
        {
            var preferredEnginePath = ResolvePreferredEnginePath();
            if (!string.IsNullOrWhiteSpace(preferredEnginePath))
            {
                EnginePath = preferredEnginePath;
    }
        }

        EngineName = !string.IsNullOrWhiteSpace(EnginePath) && File.Exists(EnginePath)
            ? Path.GetFileName(EnginePath)
            : string.Empty;

        OutputFilePath = _settings.GetValue($"{SettingsPrefix}.{nameof(OutputFilePath)}", string.Empty);
        OutputFileName = string.IsNullOrWhiteSpace(OutputFilePath) ? string.Empty : Path.GetFileName(OutputFilePath);

        Depth = _settings.GetValue($"{SettingsPrefix}.{nameof(Depth)}", Depth);
    }
    private void SaveState()
    {
        _settings.SetValue($"{SettingsPrefix}.{nameof(InputFilePath)}", InputFilePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(EnginePath)}", EnginePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(OutputFilePath)}", OutputFilePath);
        _settings.SetValue($"{SettingsPrefix}.{nameof(Depth)}", Depth);
    }
    private static string ResolvePreferredEnginePath()
    {
        var assetsRoot = Path.Combine(AppContext.BaseDirectory, "Assets");
        var assetsCandidate = FindStockfishExeUnder(assetsRoot);
        if (!string.IsNullOrWhiteSpace(assetsCandidate))
        {
            return assetsCandidate;
    }
        var localAppDataRoot = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "PgnTools",
            "Stockfish");

        return FindStockfishExeUnder(localAppDataRoot) ?? string.Empty;
    }
    private static string? FindStockfishExeUnder(string rootPath)
    {
        if (string.IsNullOrWhiteSpace(rootPath) || !Directory.Exists(rootPath))
        {
            return null;
    }
        try
        {
            return Directory.EnumerateFiles(rootPath, "*.exe", SearchOption.AllDirectories)
                .Where(path => Path.GetFileName(path).Contains("stockfish", StringComparison.OrdinalIgnoreCase))
                .OrderBy(path => path.Contains($"{Path.DirectorySeparatorChar}Assets{Path.DirectorySeparatorChar}stockfish{Path.DirectorySeparatorChar}", StringComparison.OrdinalIgnoreCase) ? 0 : 1)
                .ThenByDescending(File.GetLastWriteTimeUtc)
                .ThenBy(path => path.Length)
                .FirstOrDefault();
    }
        catch
        {
            return null;
    }
    }

    private static bool IsTemporaryPath(string path)
    {
        if (string.IsNullOrWhiteSpace(path))
        {
            return false;
    }
        var tempRoot = Path.GetFullPath(Path.GetTempPath()).TrimEnd(Path.DirectorySeparatorChar);
        var fullPath = Path.GetFullPath(path);
        return fullPath.StartsWith(tempRoot, StringComparison.OrdinalIgnoreCase);
    }
}





===== END: PgnTools\ViewModels\Tools\EleganceViewModel.cs =====

===== BEGIN: PgnTools\Views\Tools\ChessAnalyzerPage.xaml =====
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="PgnTools.Views.Tools.ChessAnalyzerPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:controls="using:PgnTools.Views.Controls"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d" NavigationCacheMode="Disabled">

    <Grid Padding="0,0,0,24">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <StackPanel Grid.Row="0" Spacing="8" Margin="0,0,0,24">
            <TextBlock Text="Chess Analyzer" Style="{StaticResource TitleTextBlockStyle}"/>
            <TextBlock Text="Run a UCI engine (like Stockfish) to annotate games with evaluations and NAGs."
                       Style="{StaticResource BodyTextBlockStyle}"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       TextWrapping="Wrap"/>
            <TextBlock Text="Note: move-by-move analysis requires SAN-to-FEN support."
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
        </StackPanel>

        <!-- Inputs -->
        <StackPanel Grid.Row="1" Spacing="12" Margin="0,0,0,24">
            <TextBlock Text="Input File"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select input PGN..."
                         Text="{x:Bind ViewModel.InputFilePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectInputFileCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <TextBlock Text="UCI Engine"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select engine executable..."
                         Text="{x:Bind ViewModel.EnginePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Download Latest"
                        Command="{x:Bind ViewModel.DownloadLatestEngineCommand}"
                        Style="{StaticResource Action}"
                        Margin="0,0,12,0"/>

                <Button Grid.Column="2"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectEngineCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <StackPanel Orientation="Horizontal" Spacing="12">
                <TextBlock Text="Depth" VerticalAlignment="Center"/>
                <NumberBox Width="180"
                           Minimum="1"
                           SmallChange="1"
                           SpinButtonPlacementMode="Inline"
                           Value="{x:Bind ViewModel.Depth, Mode=TwoWay}"/>
            </StackPanel>

            <CheckBox Content="Add Elegance tags (0-100) during analysis"
                      IsChecked="{x:Bind ViewModel.AddEleganceTags, Mode=TwoWay}"/>

            <TextBlock Text="Tablebases"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <CheckBox Content="Use Syzygy tablebases"
                      IsChecked="{x:Bind ViewModel.UseTablebases, Mode=TwoWay}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select tablebase folder..."
                         Text="{x:Bind ViewModel.TablebasePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectTablebaseFolderCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <TextBlock Text="Output File"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select output PGN..."
                         Text="{x:Bind ViewModel.OutputFilePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectOutputFileCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <StackPanel Orientation="Horizontal" Spacing="12">
                <Button Content="Run"
                        Command="{x:Bind ViewModel.RunCommand}"
                        Style="{StaticResource PrimaryAction}"/>

                <Button Content="Cancel"
                        Command="{x:Bind ViewModel.CancelCommand}"
                        Style="{StaticResource Action}"
                        IsEnabled="{x:Bind ViewModel.IsRunning, Mode=OneWay}"/>
            </StackPanel>
        </StackPanel>

        <!-- Status -->
        <ScrollViewer Grid.Row="2" VerticalScrollBarVisibility="Auto">
            <controls:ToolStatusBar StatusMessage="{x:Bind ViewModel.StatusMessage, Mode=OneWay}"
                                    StatusSeverity="{x:Bind ViewModel.StatusSeverity, Mode=OneWay}"
                                    StatusDetail="{x:Bind ViewModel.StatusDetail, Mode=OneWay}"
                                    IsRunning="{x:Bind ViewModel.IsRunning, Mode=OneWay}"
                                    IsIndeterminate="False"
                                    ProgressValue="{x:Bind ViewModel.ProgressValue, Mode=OneWay}"/>
        </ScrollViewer>
    </Grid>
</Page>








===== END: PgnTools\Views\Tools\ChessAnalyzerPage.xaml =====

===== BEGIN: PgnTools\Views\Tools\ChessAnalyzerPage.xaml.cs =====
namespace PgnTools.Views.Tools;

/// <summary>
/// Page for the Chess Analyzer tool.
/// </summary>
public sealed partial class ChessAnalyzerPage : Page
{
    private readonly bool _ownsViewModel;
    public ChessAnalyzerViewModel ViewModel { get; }

    public ChessAnalyzerPage() : this(App.GetService<ChessAnalyzerViewModel>(), ownsViewModel: true)
    {
    }

    public ChessAnalyzerPage(ChessAnalyzerViewModel viewModel, bool ownsViewModel = false)
    {
        ViewModel = viewModel ?? throw new System.ArgumentNullException(nameof(viewModel));
        _ownsViewModel = ownsViewModel;
        this.InitializeComponent();
    }

    protected override void OnNavigatedFrom(NavigationEventArgs e)
    {
        base.OnNavigatedFrom(e);
        if (_ownsViewModel)
        {
            if (ViewModel.IsRunning)
            {
                ViewModel.CancelCommand.Execute(null);
                ViewModel.DisposeWhenIdle();
            }
            else
            {
                ViewModel.Dispose();
            }
        }
    }
}


===== END: PgnTools\Views\Tools\ChessAnalyzerPage.xaml.cs =====

===== BEGIN: PgnTools\Views\Tools\ElegancePage.xaml =====
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="PgnTools.Views.Tools.ElegancePage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:controls="using:PgnTools.Views.Controls"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d" NavigationCacheMode="Disabled">

    <Grid Padding="0,0,0,24">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <StackPanel Grid.Row="0" Spacing="8" Margin="0,0,0,24">
            <TextBlock Text="Elegance" Style="{StaticResource TitleTextBlockStyle}"/>
            <TextBlock Text="Run engine analysis first, then compute Elegance (0-100) with S/C/T/Q/L details per game."
                       Style="{StaticResource BodyTextBlockStyle}"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       TextWrapping="Wrap"/>
        </StackPanel>

        <!-- Inputs -->
        <StackPanel Grid.Row="1" Spacing="12" Margin="0,0,0,24">
            <TextBlock Text="Input File"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select input PGN..."
                         Text="{x:Bind ViewModel.InputFilePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectInputFileCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <TextBlock Text="UCI Engine"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select engine executable..."
                         Text="{x:Bind ViewModel.EnginePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Download Latest"
                        Command="{x:Bind ViewModel.DownloadLatestEngineCommand}"
                        Style="{StaticResource Action}"
                        Margin="0,0,12,0"/>

                <Button Grid.Column="2"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectEngineCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <StackPanel Orientation="Horizontal" Spacing="12">
                <TextBlock Text="Depth" VerticalAlignment="Center"/>
                <NumberBox Width="180"
                           Minimum="1"
                           SmallChange="1"
                           SpinButtonPlacementMode="Inline"
                           Value="{x:Bind ViewModel.Depth, Mode=TwoWay}"/>
            </StackPanel>

            <TextBlock Text="Output File"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select output PGN..."
                         Text="{x:Bind ViewModel.OutputFilePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectOutputFileCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <StackPanel Orientation="Horizontal" Spacing="12">
                <Button Content="Run"
                        Command="{x:Bind ViewModel.RunCommand}"
                        Style="{StaticResource PrimaryAction}"/>

                <Button Content="Validate Goldens"
                        Command="{x:Bind ViewModel.ValidateGoldensCommand}"
                        Style="{StaticResource Action}"/>

                <Button Content="Cancel"
                        Command="{x:Bind ViewModel.CancelCommand}"
                        Style="{StaticResource Action}"
                        IsEnabled="{x:Bind ViewModel.IsRunning, Mode=OneWay}"/>
            </StackPanel>
        </StackPanel>

        <!-- Status -->
        <ScrollViewer Grid.Row="2" VerticalScrollBarVisibility="Auto">
            <controls:ToolStatusBar StatusMessage="{x:Bind ViewModel.StatusMessage, Mode=OneWay}"
                                    StatusSeverity="{x:Bind ViewModel.StatusSeverity, Mode=OneWay}"
                                    StatusDetail="{x:Bind ViewModel.StatusDetail, Mode=OneWay}"
                                    IsRunning="{x:Bind ViewModel.IsRunning, Mode=OneWay}"
                                    IsIndeterminate="False"
                                    ProgressValue="{x:Bind ViewModel.ProgressValue, Mode=OneWay}"/>
        </ScrollViewer>
    </Grid>
</Page>
===== END: PgnTools\Views\Tools\ElegancePage.xaml =====

===== BEGIN: PgnTools\Views\Tools\ElegancePage.xaml.cs =====
namespace PgnTools.Views.Tools;

/// <summary>
/// Page for the Elegance tool.
/// </summary>
public sealed partial class ElegancePage : Page
{
    private readonly bool _ownsViewModel;
    public EleganceViewModel ViewModel { get; }

    public ElegancePage() : this(App.GetService<EleganceViewModel>(), ownsViewModel: true)
    {
    }

    public ElegancePage(EleganceViewModel viewModel, bool ownsViewModel = false)
    {
        ViewModel = viewModel ?? throw new System.ArgumentNullException(nameof(viewModel));
        _ownsViewModel = ownsViewModel;
        this.InitializeComponent();
    }

    protected override void OnNavigatedFrom(NavigationEventArgs e)
    {
        base.OnNavigatedFrom(e);
        if (_ownsViewModel)
        {
            if (ViewModel.IsRunning)
            {
                ViewModel.CancelCommand.Execute(null);
            }
            else
            {
                ViewModel.Dispose();
            }
        }
    }
}
===== END: PgnTools\Views\Tools\ElegancePage.xaml.cs =====


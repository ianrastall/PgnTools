# Context Dump: PGN Mentor
# Date: 2026-02-06 02:10:55
# File Count: 9

===== BEGIN: Docs\PgnMentorDownloaderService.md =====
# PgnMentorDownloaderService.md

## Service Implementation: PgnMentorDownloaderService

**Version:** Current implementation (updated 2026-02-05)  
**Layer:** Service Layer (Domain Logic)  
**Dependencies:** `HttpClient`, `FileReplacementHelper`  
**Thread Safety:** Not safe for concurrent calls (static `Random` for jitter; shared `HttpClient` is fine, but jitter is not thread-safe).

## 1. Objective

Download all PGN Mentor archives referenced on the public file listing page, extract PGNs, and combine them into a single output file. The combined file is written in the same order the site provides.

## 2. Public API (Actual)

```csharp
public interface IPgnMentorDownloaderService
{
    Task DownloadAndCombineAsync(string outputFile, IProgress<string> status, CancellationToken ct);
}
```

### 2.1 Parameter Semantics
- `outputFile`: Destination PGN file path. Required.
- `status`: Status messages (phase + current file).
- `ct`: Cancels download, extraction, or writing.

## 3. High-Level Pipeline (Actual)
1. **Validate output path** and compute full paths.
2. **Fetch file list** from `https://www.pgnmentor.com/files.html`.
3. **Extract file links** for `.zip` and `.pgn` using regex.
4. **Download + append** each file in site order.
5. **Replace final output** using `FileReplacementHelper.ReplaceFile`.
6. **Cleanup** temp folder and temp output in `finally`.

## 4. Workflow Details

### 4.1 Link Discovery
- URL: `https://www.pgnmentor.com/files.html`
- Regex: `href="...(.zip|.pgn)"`
- Links are de‑duplicated with a case‑insensitive set and returned **in site order**.

### 4.2 Download Loop
For each link:
- Wait **2–4 seconds** between downloads (random jitter).
- Download to a temp folder via `DownloadWithRetryAsync`:
  - Up to 3 attempts.
  - Exponential backoff: 2s, 4s.
  - On failure after 3 attempts, exception is caught in the loop and logged via `status`.

### 4.3 Append Strategy
- Output is written to a **single temp file** with `StreamWriter` (UTF‑8, no BOM).
- **`.zip`**: Each `.pgn` entry is streamed and appended.
- **`.pgn`**: File contents are streamed and appended.
- Two blank lines are inserted between appended sources.
- **No sorting** or de‑duplication is performed. Output order is the website order.

### 4.4 Completion Rules
- If **no valid PGN content** is appended, the method reports `"No valid PGN data collected."` and exits without replacing the destination file.
- If content exists, the temp output replaces the destination file atomically.

## 5. Error Handling & Cleanup

| Scenario | Behavior |
| --- | --- |
| Download failure | Status reports `"Failed <file>"`, continues with next link |
| Extraction error | Returns false for that file; continues |
| Cancellation | Throws `OperationCanceledException`, cleanup runs |
| Temp cleanup | Always deletes temp folder and temp output file in `finally` |

## 6. Key Constraints & Constants

- **BufferSize:** 64KB (`65536`)
- **BaseUri:** `https://www.pgnmentor.com/`
- **FilesUri:** `https://www.pgnmentor.com/files.html`
- **Rate Limit:** 2–4 seconds between downloads

## 7. Usage Example (ViewModel Context)

```csharp
var progress = new Progress<string>(message =>
{
    StatusMessage = message;
    StatusDetail = BuildProgressDetail();
});

await _pgnMentorDownloaderService.DownloadAndCombineAsync(
    OutputFilePath,
    progress,
    _cancellationTokenSource.Token);
```

## 8. Limitations (Current Implementation)
- Output is **not sorted** or normalized.
- Order is **site order** only; no filtering by category or source.
- Regex link extraction only supports `.zip` and `.pgn` links on the file list page.
===== END: Docs\PgnMentorDownloaderService.md =====

===== BEGIN: PgnTools\Helpers\FilePickerHelper.cs =====
using System.Collections.Generic;
using System.Linq;
using Windows.Storage;
using Windows.Storage.Pickers;

namespace PgnTools.Helpers;

/// <summary>
/// Helper class for file/folder pickers in WinUI 3 Unpackaged apps.
/// Handles the IInitializeWithWindow pattern required for unpackaged apps.
/// </summary>
public static class FilePickerHelper
{
    /// <summary>
    /// Opens a file picker to select a single file.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <param name="fileTypeFilters">File type filters (e.g., ".pgn", ".txt").</param>
    /// <returns>The selected StorageFile, or null if cancelled.</returns>
    public static async Task<StorageFile?> PickSingleFileAsync(
        nint windowHandle,
        string? settingsIdentifier,
        params string[] fileTypeFilters)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileOpenPicker();

        // Initialize with window handle for unpackaged apps
        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var addedFilter = false;
        foreach (var filter in NormalizeFilters(fileTypeFilters))
        {
            picker.FileTypeFilter.Add(filter);
            addedFilter = true;
        }

        if (!addedFilter)
        {
            picker.FileTypeFilter.Add("*");
        }

        return await picker.PickSingleFileAsync();
    }

    /// <summary>
    /// Opens a file picker to select multiple files.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <param name="fileTypeFilters">File type filters (e.g., ".pgn", ".txt").</param>
    /// <returns>The selected StorageFiles, or empty if cancelled.</returns>
    public static async Task<IReadOnlyList<StorageFile>> PickMultipleFilesAsync(
        nint windowHandle,
        string? settingsIdentifier,
        params string[] fileTypeFilters)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileOpenPicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var addedFilter = false;
        foreach (var filter in NormalizeFilters(fileTypeFilters))
        {
            picker.FileTypeFilter.Add(filter);
            addedFilter = true;
        }

        if (!addedFilter)
        {
            picker.FileTypeFilter.Add("*");
        }

        return await picker.PickMultipleFilesAsync();
    }

    /// <summary>
    /// Opens a file picker to save a file.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="suggestedFileName">Suggested file name.</param>
    /// <param name="fileTypeChoices">Dictionary of file type descriptions to extensions.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <returns>The selected StorageFile, or null if cancelled.</returns>
    public static async Task<StorageFile?> PickSaveFileAsync(
        nint windowHandle,
        string suggestedFileName,
        Dictionary<string, IList<string>> fileTypeChoices,
        string? settingsIdentifier = null)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FileSavePicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        picker.SuggestedFileName = suggestedFileName;
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        var normalizedChoices = new List<(string Label, List<string> Extensions)>();
        foreach (var choice in fileTypeChoices)
        {
            var normalizedExtensions = NormalizeFilters(choice.Value).ToList();
            if (normalizedExtensions.Count == 0)
            {
                continue;
            }

            normalizedChoices.Add((choice.Key, normalizedExtensions));
            picker.FileTypeChoices.Add(choice.Key, normalizedExtensions);
        }

        if (string.IsNullOrWhiteSpace(picker.DefaultFileExtension))
        {
            foreach (var choice in normalizedChoices)
            {
                var extension = choice.Extensions[0];
                if (!string.IsNullOrWhiteSpace(extension))
                {
                    picker.DefaultFileExtension = extension.StartsWith(".", StringComparison.Ordinal)
                        ? extension
                        : $".{extension}";
                    break;
                }
            }
        }

        return await picker.PickSaveFileAsync();
    }

    /// <summary>
    /// Opens a folder picker to select a folder.
    /// </summary>
    /// <param name="windowHandle">The HWND of the main window.</param>
    /// <param name="settingsIdentifier">Identifier to persist picker location and view settings.</param>
    /// <returns>The selected StorageFolder, or null if cancelled.</returns>
    public static async Task<StorageFolder?> PickFolderAsync(nint windowHandle, string? settingsIdentifier = null)
    {
        ValidateWindowHandle(windowHandle);
        var picker = new FolderPicker();

        WinRT.Interop.InitializeWithWindow.Initialize(picker, windowHandle);

        picker.ViewMode = PickerViewMode.List;
        picker.SuggestedStartLocation = PickerLocationId.DocumentsLibrary;
        picker.FileTypeFilter.Add("*");
        if (!string.IsNullOrWhiteSpace(settingsIdentifier))
        {
            picker.SettingsIdentifier = settingsIdentifier;
        }

        return await picker.PickSingleFolderAsync();
    }

    private static void ValidateWindowHandle(nint windowHandle)
    {
        if (windowHandle == 0)
        {
            throw new ArgumentException("Window handle (HWND) cannot be zero.", nameof(windowHandle));
        }
    }

    private static IEnumerable<string> NormalizeFilters(IEnumerable<string> filters)
    {
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var filter in filters)
        {
            if (string.IsNullOrWhiteSpace(filter))
            {
                continue;
            }

            var trimmed = filter.Trim();
            var normalized = trimmed == "*"
                ? "*"
                : trimmed.StartsWith(".", StringComparison.Ordinal)
                    ? trimmed
                    : $".{trimmed}";

            if (seen.Add(normalized))
            {
                yield return normalized;
            }
        }
    }
}
===== END: PgnTools\Helpers\FilePickerHelper.cs =====

===== BEGIN: PgnTools\Helpers\FileReplacementHelper.cs =====
// PGNTOOLS-TABLEBASES-BEGIN
using System.IO;

namespace PgnTools.Helpers;

public static class FileReplacementHelper
{
    private const int MaxReplaceAttempts = 6;

    public static string CreateTempFilePath(string destinationPath)
    {
        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        var directory = Path.GetDirectoryName(destinationPath);
        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.GetTempPath();
        }

        var fileName = Path.GetFileName(destinationPath);
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "output";
        }

        var tempName = $".{fileName}.{Guid.NewGuid():N}.tmp";
        return Path.Combine(directory, tempName);
    }

    public static void ReplaceFile(string tempFilePath, string destinationPath)
    {
        if (string.IsNullOrWhiteSpace(tempFilePath))
        {
            throw new ArgumentException("Temp file path is required.", nameof(tempFilePath));
        }

        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        if (!File.Exists(tempFilePath))
        {
            throw new FileNotFoundException("Temp file not found.", tempFilePath);
        }

        if (Path.GetDirectoryName(destinationPath) is { Length: > 0 } directory)
        {
            Directory.CreateDirectory(directory);
        }

        Exception? lastError = null;
        for (var attempt = 1; attempt <= MaxReplaceAttempts; attempt++)
        {
            try
            {
                var backupPath = CreateBackupPath(destinationPath);
                try
                {
                    File.Replace(tempFilePath, destinationPath, backupPath, ignoreMetadataErrors: true);
                    TryDeleteBackup(backupPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    File.Move(tempFilePath, destinationPath, overwrite: true);
                    return;
                }
            }
            catch (IOException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                Thread.Sleep(attempt * 100);
            }
            catch (UnauthorizedAccessException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                Thread.Sleep(attempt * 100);
            }
        }

        throw new IOException(
            $"Failed to replace '{destinationPath}' after {MaxReplaceAttempts} attempts. The file may be locked by another process.",
            lastError);
    }

    public static async Task ReplaceFileAsync(string tempFilePath, string destinationPath, CancellationToken ct = default)
    {
        if (string.IsNullOrWhiteSpace(tempFilePath))
        {
            throw new ArgumentException("Temp file path is required.", nameof(tempFilePath));
        }

        if (string.IsNullOrWhiteSpace(destinationPath))
        {
            throw new ArgumentException("Destination file path is required.", nameof(destinationPath));
        }

        if (!File.Exists(tempFilePath))
        {
            throw new FileNotFoundException("Temp file not found.", tempFilePath);
        }

        if (Path.GetDirectoryName(destinationPath) is { Length: > 0 } directory)
        {
            Directory.CreateDirectory(directory);
        }

        Exception? lastError = null;
        for (var attempt = 1; attempt <= MaxReplaceAttempts; attempt++)
        {
            ct.ThrowIfCancellationRequested();
            try
            {
                var backupPath = CreateBackupPath(destinationPath);
                try
                {
                    File.Replace(tempFilePath, destinationPath, backupPath, ignoreMetadataErrors: true);
                    TryDeleteBackup(backupPath);
                    return;
                }
                catch (FileNotFoundException)
                {
                    File.Move(tempFilePath, destinationPath, overwrite: true);
                    return;
                }
            }
            catch (IOException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                await Task.Delay(attempt * 100, ct).ConfigureAwait(false);
            }
            catch (UnauthorizedAccessException ex) when (attempt < MaxReplaceAttempts)
            {
                lastError = ex;
                await Task.Delay(attempt * 100, ct).ConfigureAwait(false);
            }
        }

        throw new IOException(
            $"Failed to replace '{destinationPath}' after {MaxReplaceAttempts} attempts. The file may be locked by another process.",
            lastError);
    }

    private static string CreateBackupPath(string destinationPath)
    {
        var directory = Path.GetDirectoryName(destinationPath);
        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.GetTempPath();
        }

        var fileName = Path.GetFileName(destinationPath);
        if (string.IsNullOrWhiteSpace(fileName))
        {
            fileName = "output";
        }

        var backupName = $".{fileName}.{Guid.NewGuid():N}.bak";
        return Path.Combine(directory, backupName);
    }

    private static void TryDeleteBackup(string backupPath)
    {
        try
        {
            if (File.Exists(backupPath))
            {
                File.Delete(backupPath);
            }
        }
        catch
        {
        }
    }
}
// PGNTOOLS-TABLEBASES-END
===== END: PgnTools\Helpers\FileReplacementHelper.cs =====

===== BEGIN: PgnTools\Helpers\FileValidationHelper.cs =====
// PGNTOOLS-TABLEBASES-BEGIN
using System.IO;
using Windows.Storage;

namespace PgnTools.Helpers;

/// <summary>
/// Helpers for validating file and folder access selected via pickers.
/// </summary>
public static class FileValidationHelper
{
    public static async Task<(bool Success, string? ErrorMessage)> ValidateReadableFileAsync(StorageFile file)
    {
        try
        {
            using var stream = await file.OpenReadAsync();
            return (true, null);
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }

    public static async Task<(bool Success, string? ErrorMessage)> ValidateWritableFolderAsync(string folderPath)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(folderPath))
            {
                return (false, "Folder path is empty.");
            }

            Directory.CreateDirectory(folderPath);

            var testFile = Path.Combine(folderPath, $".pgn_tools_write_{Guid.NewGuid():N}");
            await File.WriteAllTextAsync(testFile, "test");
            File.Delete(testFile);

            return (true, null);
        }
        catch (Exception ex)
        {
            return (false, ex.Message);
        }
    }
}
// PGNTOOLS-TABLEBASES-END
===== END: PgnTools\Helpers\FileValidationHelper.cs =====

===== BEGIN: PgnTools\Services\IPgnMentorDownloaderService.cs =====
namespace PgnTools.Services;

/// <summary>
/// Interface for downloading and combining PGN Mentor files.
/// </summary>
public interface IPgnMentorDownloaderService
{
    Task DownloadAndCombineAsync(string outputFile, IProgress<string> status, CancellationToken ct);
}
===== END: PgnTools\Services\IPgnMentorDownloaderService.cs =====

===== BEGIN: PgnTools\Services\PgnMentorDownloaderService.cs =====
using System.IO.Compression;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using PgnTools.Helpers;

namespace PgnTools.Services;

public partial class PgnMentorDownloaderService : IPgnMentorDownloaderService
{
    private const int BufferSize = 65536;
    private static readonly Uri BaseUri = new("https://www.pgnmentor.com/");
    private static readonly Uri FilesUri = new("https://www.pgnmentor.com/files.html");
    private static readonly HttpClient HttpClient = CreateClient();
    private static readonly Random RandomJitter = new();

    public async Task DownloadAndCombineAsync(string outputFile, IProgress<string> status, CancellationToken ct)
    {
        if (string.IsNullOrWhiteSpace(outputFile)) throw new ArgumentException("Output file path is required.");

        var outputFullPath = Path.GetFullPath(outputFile);
        var tempOutputPath = FileReplacementHelper.CreateTempFilePath(outputFullPath);
        var tempFolder = Path.Combine(Path.GetTempPath(), $"PgnTools_Mentor_{Guid.NewGuid():N}");
        Directory.CreateDirectory(tempFolder);

        try
        {
            // 1. Fetch the list
            status.Report("Fetching file list...");
            var html = await HttpClient.GetStringAsync(FilesUri, ct);
            var links = ExtractLinks(html);

            if (links.Count == 0)
            {
                status.Report("No files found.");
                return;
            }

            status.Report($"Found {links.Count:N0} files.");

            // 2. Open Output Stream ONCE.
            // We append as we download to avoid storing 1000 files on disk or in RAM.
            // Note: This sacrifices Sorting. Sorting 5GB of PGNs requires a database or external merge sort.
            // For a downloader, "As Provided" order is acceptable and much safer.
            await using (var outputStream = new FileStream(tempOutputPath, FileMode.Create, FileAccess.Write, FileShare.None, BufferSize, FileOptions.Asynchronous))
            using (var writer = new StreamWriter(outputStream, new UTF8Encoding(false), BufferSize))
            {
                int processed = 0;

                for (var i = 0; i < links.Count; i++)
                {
                    ct.ThrowIfCancellationRequested();

                    // RATE LIMIT: 2 to 4 seconds delay
                    if (i > 0)
                    {
                        var delay = RandomJitter.Next(2000, 4000);
                        await Task.Delay(delay, ct);
                    }

                    var link = links[i];
                    var fileName = Path.GetFileName(link) ?? $"file_{i}.pgn";
                    var downloadUrl = new Uri(BaseUri, link);
                    var tempDownloadPath = Path.Combine(tempFolder, fileName);

                    status.Report($"Downloading {fileName} ({i + 1}/{links.Count})...");

                    try
                    {
                        await DownloadWithRetryAsync(downloadUrl, tempDownloadPath, ct);

                        bool hasContent = false;

                        if (fileName.EndsWith(".zip", StringComparison.OrdinalIgnoreCase))
                        {
                            hasContent = await ExtractAndAppendZipAsync(writer, tempDownloadPath, processed > 0, ct);
                        }
                        else if (fileName.EndsWith(".pgn", StringComparison.OrdinalIgnoreCase))
                        {
                            hasContent = await AppendPgnFileAsync(writer, tempDownloadPath, processed > 0, ct);
                        }

                        if (hasContent) processed++;

                        // Cleanup immediately
                        if (File.Exists(tempDownloadPath)) File.Delete(tempDownloadPath);
                    }
                    catch (Exception ex)
                    {
                        status.Report($"Failed {fileName}: {ex.Message}");
                    }
                }

                await writer.FlushAsync();

                if (processed == 0)
                {
                    status.Report("No valid PGN data collected.");
                    return;
                }
            }

            FileReplacementHelper.ReplaceFile(tempOutputPath, outputFullPath);
            status.Report("Download complete.");
        }
        finally
        {
            if (Directory.Exists(tempFolder)) Directory.Delete(tempFolder, true);
            if (File.Exists(tempOutputPath)) File.Delete(tempOutputPath);
        }
    }

    private static HttpClient CreateClient()
    {
        var client = new HttpClient { Timeout = TimeSpan.FromSeconds(60) };
        client.DefaultRequestHeaders.UserAgent.ParseAdd("PgnTools/1.0 (GitHub; PgnTools)");
        return client;
    }

    private static async Task DownloadWithRetryAsync(Uri uri, string destPath, CancellationToken ct)
    {
        int attempts = 0;
        while (true)
        {
            attempts++;
            try
            {
                using var response = await HttpClient.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, ct);
                response.EnsureSuccessStatusCode();
                await using var webStream = await response.Content.ReadAsStreamAsync(ct);
                await using var fileStream = new FileStream(destPath, FileMode.Create, FileAccess.Write, FileShare.None, BufferSize, FileOptions.Asynchronous);
                await webStream.CopyToAsync(fileStream, ct);
                return;
            }
            catch (Exception) when (attempts < 3)
            {
                await Task.Delay(TimeSpan.FromSeconds(2 * attempts), ct);
            }
        }
    }

    private static async Task<bool> ExtractAndAppendZipAsync(StreamWriter writer, string zipPath, bool addSeparator, CancellationToken ct)
    {
        try
        {
            using var archive = ZipFile.OpenRead(zipPath);
            bool foundAny = false;
            foreach (var entry in archive.Entries.Where(e => e.FullName.EndsWith(".pgn", StringComparison.OrdinalIgnoreCase)))
            {
                if (addSeparator || foundAny)
                {
                    await writer.WriteLineAsync();
                    await writer.WriteLineAsync();
                }

                await using var s = entry.Open();
                using var reader = new StreamReader(s, Encoding.UTF8, detectEncodingFromByteOrderMarks: true);
                string? line;
                while ((line = await reader.ReadLineAsync(ct)) != null)
                {
                    await writer.WriteLineAsync(line);
                }
                foundAny = true;
            }
            return foundAny;
        }
        catch { return false; }
    }

    private static async Task<bool> AppendPgnFileAsync(StreamWriter writer, string pgnPath, bool addSeparator, CancellationToken ct)
    {
        if (addSeparator)
        {
            await writer.WriteLineAsync();
            await writer.WriteLineAsync();
        }

        using var reader = new StreamReader(pgnPath, Encoding.UTF8, detectEncodingFromByteOrderMarks: true);
        string? line;
        while ((line = await reader.ReadLineAsync(ct)) != null)
        {
            await writer.WriteLineAsync(line);
        }
        return true;
    }

    private static List<string> ExtractLinks(string html)
    {
        var matches = LinkRegex().Matches(html);
        var links = new List<string>();
        var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (Match match in matches)
        {
            if (!match.Success)
            {
                continue;
            }

            var url = match.Groups["url"].Value;
            if (string.IsNullOrWhiteSpace(url))
            {
                continue;
            }

            if (seen.Add(url))
            {
                links.Add(url);
            }
        }
        // Return as-is (site order), usually chronological
        return links;
    }

    [GeneratedRegex("href\\s*=\\s*[\"'](?<url>[^\"'#]+?\\.(?:zip|pgn))[\"']", RegexOptions.IgnoreCase | RegexOptions.Compiled)]
    private static partial Regex LinkRegex();
}
===== END: PgnTools\Services\PgnMentorDownloaderService.cs =====

===== BEGIN: PgnTools\ViewModels\Tools\PgnMentorDownloaderViewModel.cs =====
using System.IO;

namespace PgnTools.ViewModels.Tools;

/// <summary>
/// ViewModel for the PGN Mentor Downloader tool.
/// </summary>
public partial class PgnMentorDownloaderViewModel(
    IPgnMentorDownloaderService pgnMentorDownloaderService,
    IWindowService windowService,
    IAppSettingsService settings) : BaseViewModel, IInitializable, IDisposable
{
    private readonly IPgnMentorDownloaderService _pgnMentorDownloaderService = pgnMentorDownloaderService;
    private readonly IAppSettingsService _settings = settings;
    private readonly IWindowService _windowService = windowService;
    private CancellationTokenSource? _cancellationTokenSource;
    private readonly SemaphoreSlim _executionLock = new(1, 1);
    private bool _disposed;
    private const string SettingsPrefix = nameof(PgnMentorDownloaderViewModel);

    [ObservableProperty]
    private string _outputFilePath = string.Empty;

    [ObservableProperty]
    private string _outputFileName = string.Empty;

    [ObservableProperty]
    private bool _isRunning;

    [ObservableProperty]
    private string _statusMessage = "Select output file to download and combine PGNs";
    public void Initialize()
    {
        Title = "PGN Mentor Downloader";
        StatusSeverity = InfoBarSeverity.Informational;
        LoadState();
    }
    [RelayCommand]
    private async Task SelectOutputFileAsync()
    {
        try
        {
            var suggestedName = "pgnmentor_collection.pgn";
            var file = await FilePickerHelper.PickSaveFileAsync(
                _windowService.WindowHandle,
                suggestedName,
                new Dictionary<string, IList<string>>
                {
                    { "PGN Files", [".pgn"] }
                },
                $"{SettingsPrefix}.Picker.Output");

            if (file != null)
            {
                OutputFilePath = file.Path;
                OutputFileName = file.Name;
                StatusMessage = $"Selected output: {file.Name}";
                StatusSeverity = InfoBarSeverity.Informational;
    }
        }
        catch (Exception ex)
        {
            StatusMessage = $"Error selecting output file: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
    }
    }

    [RelayCommand(CanExecute = nameof(CanRun))]
    private async Task RunAsync()
    {
        if (string.IsNullOrWhiteSpace(OutputFilePath))
        {
            return;
    }
        if (!await _executionLock.WaitAsync(0))
        {
            return;
    }
        try
        {
            IsRunning = true;
            StatusMessage = "Downloading PGN Mentor files...";
            StatusSeverity = InfoBarSeverity.Informational;
            StartProgressTimer();
            StatusDetail = BuildProgressDetail();

            _cancellationTokenSource = new CancellationTokenSource();
            var progress = new Progress<string>(message =>
            {
                StatusMessage = message;
                StatusDetail = BuildProgressDetail();
            });

            await _pgnMentorDownloaderService.DownloadAndCombineAsync(
                OutputFilePath,
                progress,
                _cancellationTokenSource.Token);

            StatusMessage = "PGN Mentor download complete.";
            StatusSeverity = InfoBarSeverity.Success;
            StatusDetail = BuildProgressDetail();
    }
        catch (OperationCanceledException)
        {
            StatusMessage = "PGN Mentor download cancelled";
            StatusSeverity = InfoBarSeverity.Warning;
            StatusDetail = BuildProgressDetail();
    }
        catch (Exception ex)
        {
            StatusMessage = $"Error: {ex.Message}";
            StatusSeverity = InfoBarSeverity.Error;
            StatusDetail = BuildProgressDetail();
    }
        finally
        {
            IsRunning = false;
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _executionLock.Release();
            StopProgressTimer();
    }
    }

    private bool CanRun() =>
        !IsRunning && !string.IsNullOrWhiteSpace(OutputFilePath);

    [RelayCommand]
    private void Cancel()
    {
        _cancellationTokenSource?.Cancel();
        StatusMessage = "Cancelling...";
        StatusSeverity = InfoBarSeverity.Warning;
        StatusDetail = BuildProgressDetail();
    }
    partial void OnOutputFilePathChanged(string value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    partial void OnIsRunningChanged(bool value)
    {
        RunCommand.NotifyCanExecuteChanged();
    }
    public void Dispose()
    {
        if (_disposed)
        {
            return;
    }
        _disposed = true;
        SaveState();
        _cancellationTokenSource?.Cancel();
        _cancellationTokenSource?.Dispose();
        _cancellationTokenSource = null;
        _executionLock.Dispose();
    }
    private void LoadState()
    {
        OutputFilePath = _settings.GetValue($"{SettingsPrefix}.{nameof(OutputFilePath)}", OutputFilePath);
        OutputFileName = string.IsNullOrWhiteSpace(OutputFilePath) ? string.Empty : Path.GetFileName(OutputFilePath);
    }
    private void SaveState()
    {
        _settings.SetValue($"{SettingsPrefix}.{nameof(OutputFilePath)}", OutputFilePath);
    }
}






===== END: PgnTools\ViewModels\Tools\PgnMentorDownloaderViewModel.cs =====

===== BEGIN: PgnTools\Views\Tools\PgnMentorDownloaderPage.xaml =====
<?xml version="1.0" encoding="utf-8"?>
<Page
    x:Class="PgnTools.Views.Tools.PgnMentorDownloaderPage"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:controls="using:PgnTools.Views.Controls"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="d" NavigationCacheMode="Disabled">

    <Grid Padding="0,0,0,24">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <!-- Header -->
        <StackPanel Grid.Row="0" Spacing="8" Margin="0,0,0,24">
            <TextBlock Text="PGN Mentor Downloader" Style="{StaticResource TitleTextBlockStyle}"/>
            <TextBlock Text="Download PGN Mentor archives, extract PGNs, and combine them into one sorted file."
                       Style="{StaticResource BodyTextBlockStyle}"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"
                       TextWrapping="Wrap"/>
        </StackPanel>

        <!-- File Selection -->
        <StackPanel Grid.Row="1" Spacing="12" Margin="0,0,0,24">
            <TextBlock Text="Output File"
                       Foreground="{ThemeResource TextFillColorSecondaryBrush}"/>
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBox Grid.Column="0"
                         PlaceholderText="Select output PGN..."
                         Text="{x:Bind ViewModel.OutputFilePath, Mode=OneWay}"
                         IsReadOnly="True"
                         Margin="0,0,12,0"/>

                <Button Grid.Column="1"
                        Content="Browse..."
                        Command="{x:Bind ViewModel.SelectOutputFileCommand}"
                        Style="{StaticResource Action}"/>
            </Grid>

            <StackPanel Orientation="Horizontal" Spacing="12">
                <Button Content="Run"
                        Command="{x:Bind ViewModel.RunCommand}"
                        Style="{StaticResource PrimaryAction}"/>

                <Button Content="Cancel"
                        Command="{x:Bind ViewModel.CancelCommand}"
                        Style="{StaticResource Action}"
                        IsEnabled="{x:Bind ViewModel.IsRunning, Mode=OneWay}"/>
            </StackPanel>
        </StackPanel>

        <!-- Status -->
        <ScrollViewer Grid.Row="2" VerticalScrollBarVisibility="Auto">
            <controls:ToolStatusBar StatusMessage="{x:Bind ViewModel.StatusMessage, Mode=OneWay}"
                                    StatusSeverity="{x:Bind ViewModel.StatusSeverity, Mode=OneWay}"
                                    StatusDetail="{x:Bind ViewModel.StatusDetail, Mode=OneWay}"
                                    IsRunning="{x:Bind ViewModel.IsRunning, Mode=OneWay}"
                                    IsIndeterminate="True"/>
        </ScrollViewer>
    </Grid>
</Page>







===== END: PgnTools\Views\Tools\PgnMentorDownloaderPage.xaml =====

===== BEGIN: PgnTools\Views\Tools\PgnMentorDownloaderPage.xaml.cs =====
namespace PgnTools.Views.Tools;

/// <summary>
/// Page for the PGN Mentor Downloader tool.
/// </summary>
public sealed partial class PgnMentorDownloaderPage : Page
{
    private readonly bool _ownsViewModel;
    public PgnMentorDownloaderViewModel ViewModel { get; }

    public PgnMentorDownloaderPage() : this(App.GetService<PgnMentorDownloaderViewModel>(), ownsViewModel: true)
    {
    }

    public PgnMentorDownloaderPage(PgnMentorDownloaderViewModel viewModel, bool ownsViewModel = false)
    {
        ViewModel = viewModel ?? throw new System.ArgumentNullException(nameof(viewModel));
        _ownsViewModel = ownsViewModel;
        this.InitializeComponent();
    }

    protected override void OnNavigatedFrom(NavigationEventArgs e)
    {
        base.OnNavigatedFrom(e);
        if (_ownsViewModel)
        {
            if (ViewModel.IsRunning)
            {
                ViewModel.CancelCommand.Execute(null);
            }
            else
            {
                ViewModel.Dispose();
            }
        }
    }
}

===== END: PgnTools\Views\Tools\PgnMentorDownloaderPage.xaml.cs =====

